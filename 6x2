
/**
 * Plugin Name: KT Cigar Enhanced Matcher
 * Description: Match supplier products to KT Cigar catalog SKUs with integrated keyword categorization
 * Version: 2.0.0
 * Author: Claude
 */

// Exit if accessed directly
if (!defined("ABSPATH")) {
    exit;
}

class KT_Cigar_Enhanced_Matcher {
    private $plugin_slug = "ktcigar-enhanced-matcher";
    private $master_table = "master_products";
    private $mapping_table = "cigar_supplier_mapping";
    private $suppliers_table = "cigar_suppliers";
    private $template_table = "cigar_csv_templates";
    private $data_file_path = null;
    private $debug_log = array();
    private $enable_logging = true; // Switch to turn logging on/off
    
    // Keyword categorization system
    private $keyword_categories = array(
        "brand" => array("color" => "#e7f4ff", "label" => "Brand"),
        "model" => array("color" => "#d4edda", "label" => "Series/Model"),
        "vitola" => array("color" => "#fff3cd", "label" => "Vitola/Size"),
        "special_edition" => array("color" => "#f8d7da", "label" => "Special Edition"),
        "year" => array("color" => "#e2e3e5", "label" => "Year"),
        "count" => array("color" => "#d0d0ff", "label" => "Count"),
        "dimensions" => array("color" => "#ffd8b2", "label" => "Dimensions"),
        "packaging" => array("color" => "#ddebf7", "label" => "Packaging"),
        "generic" => array("color" => "#e7e7e7", "label" => "Generic")
    );
    
    // Common filter words
    private $common_filter_words = array(
        "盒", "盒装", "box", "装", "只", "支", "五只", "五支", "三只", "三支", 
        "四只", "四支", "pcs", "片", "条", "整盒", "整箱", "带盒", "带管", 
        "铝管装", "礼盒", "普通装", "单支", "裸支", "非卖品", "定制", "茄", 
        "雪茄", "cigar", "cigars", "烟", "单盒", "高端", "限量", "限定", "特殊", 
        "特制", "精选", "厂家", "正品", "产品", "精美", "小", "大", "中号", "特号", 
        "产地", "古巴", "古代", "cuba", "全球", "包邮", "正品", "原装", "现货", 
        "新品", "无盒", "年", "年份", "打火机"
    );
    
   /**
    * Constructor
    */
    public function __construct() {
    // Set data file path
    $this->data_file_path = WP_CONTENT_DIR . '/cigar-mappings-data.php';
    
    // Delay KT_Cigar_Mappings initialization until after all plugins loaded
    add_action('plugins_loaded', array($this, 'initialize_kt_mappings_now'), 20);
    
    // Add admin menu
    add_action("admin_menu", array($this, "add_admin_menu"));
    // Register AJAX handlers
    add_action("wp_ajax_kt_cigar_matcher_upload_csv", array($this, "ajax_upload_supplier_csv"));
    add_action("wp_ajax_kt_cigar_matcher_check_status", array($this, "ajax_check_status"));
    add_action("wp_ajax_kt_cigar_matcher_process_batch", array($this, "ajax_process_batch_products"));
    add_action("wp_ajax_kt_cigar_matcher_save_mapping", array($this, "ajax_save_mapping"));
    add_action("wp_ajax_kt_cigar_matcher_delete_mapping", array($this, "ajax_delete_mapping"));
    add_action("wp_ajax_kt_cigar_matcher_export_mappings", array($this, "ajax_export_mappings"));
    add_action("wp_ajax_kt_cigar_matcher_save_template", array($this, "ajax_save_template"));
    add_action("wp_ajax_kt_cigar_matcher_load_template", array($this, "ajax_load_template"));
    add_action("wp_ajax_kt_cigar_matcher_delete_template", array($this, "ajax_delete_template"));
    add_action("wp_ajax_kt_cigar_matcher_list_templates", array($this, "ajax_list_templates"));
    add_action("wp_ajax_kt_cigar_matcher_search_sku", array($this, "ajax_search_sku"));
    add_action("wp_ajax_kt_cigar_matcher_search_brand", array($this, "ajax_search_by_brand"));
    add_action("wp_ajax_kt_cigar_matcher_quick_map", array($this, "ajax_quick_map"));
    add_action("wp_ajax_kt_cigar_matcher_toggle_logging", array($this, "ajax_toggle_logging"));
    add_action('admin_init', array($this, 'init_database_preprocessing'));
    add_action("wp_ajax_kt_cigar_matcher_debug_keywords", array($this, "ajax_debug_keywords"));
    add_action("wp_ajax_kt_cigar_matcher_clear_cache", array($this, "ajax_clear_cache"));
    add_action("wp_ajax_kt_cigar_matcher_diagnose_brand", array($this, "ajax_diagnose_brand_extraction"));
    add_action("wp_ajax_kt_cigar_matcher_debug_brand_comparison", array($this, "ajax_debug_brand_comparison"));
    add_action("wp_ajax_kt_cigar_matcher_check_keywords_table", array($this, "ajax_check_keywords_table"));
    add_action("wp_ajax_kt_cigar_matcher_get_db_keywords", array($this, "ajax_get_db_keywords"));
    
    // Create tables on activation
    register_activation_hook(__FILE__, array($this, "create_tables"));
    
		
		// Ensure KT_Cigar_Mappings is loaded and initialized
add_action('plugins_loaded', function() {
    if (class_exists('KT_Cigar_Mappings')) {
        KT_Cigar_Mappings::init(true);
        $this->log_debug("KT_Cigar_Mappings initialized successfully");
    } else {
        $this->log_debug("WARNING: KT_Cigar_Mappings class not found");
    }
}, 25);
		
		
		
		
    // Check if data file exists
    if (!file_exists($this->data_file_path)) {
        add_action('admin_notices', function() {
            echo '<div class="notice notice-error"><p>KT Cigar Matcher: Data file not found at ' . esc_html($this->data_file_path) . '</p></div>';
        });
    }
    
    // Load logging preference from option
    $this->enable_logging = get_option('kt_cigar_matcher_enable_logging', true);
}
/**
 * Ensure KT_Cigar_Mappings is loaded before processing
 */
private function ensure_kt_mappings_loaded() {
    if (!class_exists('KT_Cigar_Mappings')) {
        $this->log_debug("KT_Cigar_Mappings class not found, attempting to load...");
        return false;
    }
    
    // Check if required methods exist
    $required_methods = array('process_supplier_product', 'process_internal_product', 'get_main_brand');
    foreach ($required_methods as $method) {
        if (!method_exists('KT_Cigar_Mappings', $method)) {
            $this->log_debug("Required method $method not found in KT_Cigar_Mappings");
            return false;
        }
    }
    
    return true;
}
/**
 * Initialize KT_Cigar_Mappings immediately - no hooks, no delays  
 */

public function initialize_kt_mappings_now() {

    // Check if KT_Cigar_Mappings exists at all
    if (!class_exists('KT_Cigar_Mappings')) {
        $this->log_debug("CRITICAL: KT_Cigar_Mappings class does not exist - plugin dependency missing");
        return false;
    }
    
    // Try to initialize it
    try {
        if (method_exists('KT_Cigar_Mappings', 'init')) {
            KT_Cigar_Mappings::init(true);
            $this->log_debug("KT_Cigar_Mappings::init() called successfully");
        }
        
        // Verify critical methods exist
        $missing_methods = array();
        $required_methods = array('get_main_brand', 'process_supplier_product', 'process_internal_product');
        
        foreach ($required_methods as $method) {
            if (!method_exists('KT_Cigar_Mappings', $method)) {
                $missing_methods[] = $method;
            }
        }
        
        if (!empty($missing_methods)) {
            $this->log_debug("CRITICAL: Missing methods: " . implode(', ', $missing_methods));
            return false;
        }
        
        $this->log_debug("SUCCESS: All required KT_Cigar_Mappings methods found");
        return true;
        
    } catch (Exception $e) {
        $this->log_debug("ERROR initializing KT_Cigar_Mappings: " . $e->getMessage());
        return false;
    }
}
	
	
	
	

	
	
	
	
	
	
/**
 * AJAX handler for diagnosing brand extraction
 */
public function ajax_diagnose_brand_extraction() {
    check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
    
    if (!current_user_can("manage_options")) {
        wp_send_json_error(array("message" => "Insufficient permissions"));
    }
    
    // Run the brand extraction diagnosis
    $this->debug_brand_extraction_comparison();
    
    // Get some basic statistics
    $summary = array(
        "message" => "Brand extraction diagnosis completed",
        "check_log" => "Check the debug log file for detailed results: " . WP_CONTENT_DIR . '/cigar-matcher-debug.log',
        "timestamp" => date('Y-m-d H:i:s')
    );
    
    wp_send_json_success(array(
        "message" => "Diagnosis completed successfully",
        "summary" => $summary
    ));
}	
	
	
	
	
	
	
    /**
     * Add debug log entry
     */
	
public function init_database_preprocessing() {
    // Only run on our plugin pages
    if (isset($_GET['page']) && strpos($_GET['page'], 'ktcigar') !== false) {
        $this->preprocess_all_database_products();
    }
}
	
	
	
	
	
    private function log_debug($message) {
        if (!$this->enable_logging) {
            return;
        }
        
        $this->debug_log[] = date('Y-m-d H:i:s') . ' - ' . $message;
        
        // Also log to file
        $log_file = WP_CONTENT_DIR . '/cigar-matcher-debug.log';
        file_put_contents($log_file, date('Y-m-d H:i:s') . ' - ' . $message . "\n", FILE_APPEND);
    }
    
	/**
 * Get keywords from database table by SKU
 */
private function get_keywords_from_table($sku) {
    global $wpdb;
    $keywords_table = $wpdb->prefix . 'kt_cigar_processed_keywords';
    
    // Check if table exists
    if ($wpdb->get_var("SHOW TABLES LIKE '$keywords_table'") != $keywords_table) {
        $this->log_debug("Keywords table doesn't exist, using fallback for SKU: $sku");
        return array("FULL:" . strtolower($sku));
    }
	// Also check if table has any data
$row_count = $wpdb->get_var("SELECT COUNT(*) FROM $keywords_table");
if ($row_count == 0) {
    $this->log_debug("Keywords table is empty, needs population");
    // Optionally trigger a rebuild here
    return $this->get_potential_database_matches_cache($processed_product);
}
    
    // Get keywords for this SKU
    $result = $wpdb->get_var($wpdb->prepare(
        "SELECT keywords FROM $keywords_table WHERE sku = %s",
        $sku
    ));
    
    if (!empty($result)) {
        $decoded_keywords = json_decode($result, true);
        if (is_array($decoded_keywords) && !empty($decoded_keywords)) {
            $this->log_debug("Retrieved " . count($decoded_keywords) . " keywords from table for SKU: $sku");
            return $decoded_keywords;
        }
    }
    
    // Fallback
    $this->log_debug("No keywords found in table for SKU: $sku, using fallback");
    return array("FULL:" . strtolower($sku));
}
	
	
	
	/**
 * Pre-process all database products for keywords (called during plugin init)
 */
private function preprocess_all_database_products() {
    global $wpdb;
    $master_table = $wpdb->prefix . $this->master_table;
    
    // Check if we already have cached processed products
    $cache_key = 'kt_cigar_processed_db_products_v2';
    $cached_products = get_transient($cache_key);
    
    if ($cached_products !== false) {
        $this->log_debug("Using cached processed database products: " . count($cached_products) . " products");
        return $cached_products;
    }
    
    // Get all database products
    $query = "SELECT id, sku, product_title, brand, seat_row, seat_number 
              FROM $master_table 
              WHERE (product_type = 'cigar' OR product_type = '') 
              ORDER BY brand ASC, sku ASC";
    
    $all_products = $wpdb->get_results($query);
    $processed_products = array();
    
    $this->log_debug("Pre-processing " . count($all_products) . " database products for keywords...");
    
    foreach ($all_products as $db_product) {
        $dimensions = "";
        if (!empty($db_product->seat_row) || !empty($db_product->seat_number)) {
            $dimensions = (!empty($db_product->seat_row) ? $db_product->seat_row : "") . "/" . 
                          (!empty($db_product->seat_number) ? $db_product->seat_number : "");
        }
        
     // Extract keywords NOW - with better error handling
$processed = array();
if (!$this->ensure_kt_mappings_loaded()) {
    $this->log_debug("KT_Cigar_Mappings not available, using fallback");
    return array("keywords" => array("FULL:" . strtolower($product_title)));
}
		
if (class_exists('KT_Cigar_Mappings')) {
	
	
	
	
    try {
        $processed = KT_Cigar_Mappings::process_internal_product(
            $db_product->sku,
            $db_product->product_title,
            $dimensions
        );
		// ADD THIS DEBUG LOGGING:
    if (in_array($db_product->sku, ['DV001', 'DV042', 'MC001'])) { // Debug specific SKUs
        $this->log_debug("=== DB PRODUCT KEYWORD EXTRACTION DEBUG ===");
        $this->log_debug("SKU: " . $db_product->sku);
        $this->log_debug("Title: " . $db_product->product_title);
        $this->log_debug("Dimensions: " . $dimensions);
        $this->log_debug("Extracted keywords count: " . count($processed["keywords"] ?? []));
        $this->log_debug("Extracted keywords: " . json_encode($processed["keywords"] ?? []));
        $this->log_debug("=== END DEBUG ===");
    }
        
        // Ensure keywords array exists and has content
        if (empty($processed["keywords"]) || !is_array($processed["keywords"])) {
            $processed["keywords"] = array("FULL:" . strtolower($db_product->product_title));
            $this->log_debug("WARNING: No keywords from KT_Cigar_Mappings for " . $db_product->sku . ", using fallback");
        }
    } catch (Exception $e) {
        $this->log_debug("ERROR: KT_Cigar_Mappings failed for " . $db_product->sku . ": " . $e->getMessage());
        $processed = array(
            "sku" => $db_product->sku,
            "title" => $db_product->product_title,
            "keywords" => array("FULL:" . strtolower($db_product->product_title))
        );
    }
} else {
    // Fallback - minimal processing
    $processed = array(
        "sku" => $db_product->sku,
        "title" => $db_product->product_title,
        "keywords" => array("FULL:" . strtolower($db_product->product_title))
    );
}

// Force add basic keywords if still empty
if (empty($processed["keywords"])) {
    $processed["keywords"] = array("FULL:" . strtolower($db_product->product_title));
    $this->log_debug("FORCED keywords for " . $db_product->sku);
}
        // Store the processed data
        $processed_products[$db_product->sku] = array(
            'sku' => $db_product->sku,
            'id' => $db_product->id,
            'title' => $db_product->product_title,
            'brand' => $db_product->brand,
            'seat_row' => $db_product->seat_row,
            'seat_number' => $db_product->seat_number,
            'keywords' => !empty($processed["keywords"]) ? $processed["keywords"] : array(),
            'processed_data' => $processed
        );
    }
    
    // Cache for 1 hour
    set_transient($cache_key, $processed_products, 60 * 60);
    
    $this->log_debug("Pre-processed and cached " . count($processed_products) . " database products");
    return $processed_products;
}
	
	
	
	
	
	
	
    /**
     * Display debug message
     */
    private function display_debug_message($message, $type = 'info') {
        // Log to file if logging is enabled
        if ($this->enable_logging) {
            $this->log_debug($message);
        }
        
        // Return formatted HTML for error/notice
        $class = 'notice';
        switch ($type) {
            case 'error':
                $class = 'notice-error';
                break;
            case 'warning':
                $class = 'notice-warning';
                break;
            case 'success':
                $class = 'notice-success';
                break;
            default:
                $class = 'notice-info';
        }
        
        return '<div class="notice ' . $class . '">' .
               '<p>' . esc_html($message) . '</p>' .
               '</div>';
    }
    
    /**
     * Get any accumulated debug logs for display
     */
    private function get_debug_logs($limit = 10) {
        if (empty($this->debug_log)) {
            return '<p>No debug logs available.</p>';
        }
        
        // Get the most recent logs, limited to $limit entries
        $recent_logs = array_slice($this->debug_log, -$limit);
        
        $output = '';
        foreach ($recent_logs as $log) {
            $output .= '<div class="debug-log-entry">' . esc_html($log) . '</div>';
        }
        
        return $output;
    }
    
    /**
     * Force display all errors and messages
     */
    private function show_all_errors() {
        // Get all WordPress errors
        global $wpdb;
        
        // Log database errors
        if (!empty($wpdb->last_error)) {
            $this->log_debug("Database error: " . $wpdb->last_error);
            return $this->display_debug_message("Database error: " . $wpdb->last_error, 'error');
        }
        
        // Check for PHP errors
        $last_error = error_get_last();
        if (!empty($last_error)) {
            $error_message = "PHP Error: " . $last_error['message'] . " in " . $last_error['file'] . " on line " . $last_error['line'];
            $this->log_debug($error_message);
            return $this->display_debug_message($error_message, 'error');
        }
        
        // Check for table existence
        global $wpdb;
        $master_table = $wpdb->prefix . $this->master_table;
        $mapping_table = $wpdb->prefix . $this->mapping_table;
        $suppliers_table = $wpdb->prefix . $this->suppliers_table;
        
        $errors = [];
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$master_table'") != $master_table) {
            $errors[] = "Master table '$master_table' does not exist!";
        }
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$mapping_table'") != $mapping_table) {
            $errors[] = "Mapping table '$mapping_table' does not exist!";
        }
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$suppliers_table'") != $suppliers_table) {
            $errors[] = "Suppliers table '$suppliers_table' does not exist!";
        }
        
        if (!empty($errors)) {
            $error_message = implode("<br>", $errors);
            $this->log_debug($error_message);
            return $this->display_debug_message($error_message, 'error');
        }
        
        // No errors found
        return '';
    }
    
    /**
     * AJAX handler for toggling logging
     */
    public function ajax_toggle_logging() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        $enable = isset($_POST["enable"]) ? (bool)$_POST["enable"] : false;
        $this->enable_logging = $enable;
        update_option('kt_cigar_matcher_enable_logging', $enable);
        
        wp_send_json_success(array(
            "message" => "Logging " . ($enable ? "enabled" : "disabled"),
            "status" => $enable
        ));
    }
    
    /**
     * Create required tables
     */
    public function create_tables() {
        global $wpdb;
        $charset_collate = $wpdb->get_charset_collate();
        
        // Mapping table
        $mapping_table = $wpdb->prefix . $this->mapping_table;
        
        $sql = "CREATE TABLE IF NOT EXISTS $mapping_table (
            id bigint(20) NOT NULL AUTO_INCREMENT,
            supplier_id varchar(255) NOT NULL,
            supplier_name varchar(255) NOT NULL,
            supplier_title text NOT NULL,
            kt_sku varchar(255) NOT NULL,
            match_confidence varchar(50) NOT NULL,
            matched_terms text,
            created_at datetime DEFAULT CURRENT_TIMESTAMP,
            updated_at datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            PRIMARY KEY  (id),
            KEY supplier_name (supplier_name),
            KEY supplier_id (supplier_id),
            KEY kt_sku (kt_sku),
            KEY match_confidence (match_confidence)
        ) $charset_collate;";
        
        // Suppliers table
        $suppliers_table = $wpdb->prefix . $this->suppliers_table;
        
        $sql .= "CREATE TABLE IF NOT EXISTS $suppliers_table (
            id bigint(20) NOT NULL AUTO_INCREMENT,
            supplier_name varchar(255) NOT NULL,
            supplier_description text,
            mapping_count int(11) DEFAULT '0',
            created_at datetime DEFAULT CURRENT_TIMESTAMP,
            updated_at datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            PRIMARY KEY  (id),
            UNIQUE KEY supplier_name (supplier_name)
        ) $charset_collate;";
        
        // Templates table
        $templates_table = $wpdb->prefix . $this->template_table;
        
        $sql .= "CREATE TABLE IF NOT EXISTS $templates_table (
            id bigint(20) NOT NULL AUTO_INCREMENT,
            template_name varchar(255) NOT NULL,
            supplier_name varchar(255) NOT NULL,
            column_mappings text NOT NULL,
            created_at datetime DEFAULT CURRENT_TIMESTAMP,
            updated_at datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            PRIMARY KEY  (id),
            UNIQUE KEY template_name (template_name)
        ) $charset_collate;";
        
        require_once(ABSPATH . "wp-admin/includes/upgrade.php");
        dbDelta($sql);
    }
    
    /**
     * Add admin menu
     */
    public function add_admin_menu() {
        // Main menu
        add_menu_page(
            "Cigar Supplier Matcher",
            "Cigar Matcher",
            "manage_options",
            $this->plugin_slug,
            array($this, "display_main_page"),
            "dashicons-database-import",
            300000
        );
        
        // Mappings submenu
        add_submenu_page(
            $this->plugin_slug,
            "Supplier Mappings",
            "Mappings",
            "manage_options",
            $this->plugin_slug . "-mappings",
            array($this, "display_mappings_page")
        );
        
        // Templates submenu
        add_submenu_page(
            $this->plugin_slug,
            "CSV Templates",
            "Templates",
            "manage_options",
            $this->plugin_slug . "-templates",
            array($this, "display_templates_page")
        );
        
        // Add new debug page
        add_submenu_page(
            $this->plugin_slug,
            "Keyword Debug",
            "Keyword Debug",
            "manage_options",
            $this->plugin_slug . "-debug",
            array($this, "display_debug_page")
        );
    }
    
    /**
     * Load the data file
     */
    private function load_data_file() {
        static $data_file = null;
        
        if ($data_file === null) {
            // Try to get data file from KT_Cigar_Mappings if available
            if (class_exists('KT_Cigar_Mappings') && property_exists('KT_Cigar_Mappings', 'data_file')) {
                $reflection = new ReflectionClass('KT_Cigar_Mappings');
                $property = $reflection->getProperty('data_file');
                $property->setAccessible(true);
                $data_file = $property->getValue(null);
                
                if (!empty($data_file)) {
                    $this->log_debug("Data file loaded from KT_Cigar_Mappings");
                    return $data_file;
                }
            }
            
            // Fallback to loading file directly
            if (file_exists($this->data_file_path)) {
                try {
                    $data_file = include $this->data_file_path;
                    if (!is_array($data_file)) {
                        $this->log_debug("Data file did not return an array");
                        $data_file = array();
                    }
                } catch (Exception $e) {
                    $this->log_debug("Error loading data file: " . $e->getMessage());
                    $data_file = array();
                }
            } else {
                $error_message = "Data file not found: " . $this->data_file_path;
                $this->log_debug($error_message);
                add_action('admin_notices', function() use ($error_message) {
                    echo $this->display_debug_message($error_message, 'error');
                });
                $data_file = array();
            }
        }
        
        return $data_file;
    }
    
    /**
     * Display main page
     */
    public function display_main_page() {
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
        // Check data file
        $data_file = $this->load_data_file();
        
        // Direct testing of critical plugin components
        try {
            // 1. Test data file access and structure
            if (empty($data_file)) {
                throw new Exception("Data file could not be loaded or is empty");
            } else {
                // Check basic structure expected in data file
                if (!isset($data_file['brands']) || (!isset($data_file['brands']['cuban']) && !isset($data_file['brands']['non_cuban']))) {
                    throw new Exception("Data file structure is invalid - missing brands section");
                }
            }

            // 2. Test direct database table access
            global $wpdb;
            $master_table = $wpdb->prefix . $this->master_table;
            $test_query = "SELECT COUNT(*) FROM $master_table";
            $result = $wpdb->get_var($test_query);
            if ($result === null && $wpdb->last_error) {
                throw new Exception("Database error: " . $wpdb->last_error);
            }

            // 3. Test debug log writing
            $test_log_file = WP_CONTENT_DIR . '/cigar-matcher-debug.log';
            if (!is_writable($test_log_file) && file_exists($test_log_file)) {
                throw new Exception("Debug log file is not writable: " . $test_log_file);
            }

            // 4. Test file system permissions for uploads
            $upload_dir = wp_upload_dir();
            $supplier_dir = $upload_dir["basedir"] . "/cigar-supplier-csv";
            if (!file_exists($supplier_dir)) {
                if (!@mkdir($supplier_dir, 0755, true)) {
                    throw new Exception("Could not create supplier CSV directory: " . $supplier_dir);
                }
            } else if (!is_writable($supplier_dir)) {
                throw new Exception("Supplier CSV directory is not writable: " . $supplier_dir);
            }

        } catch (Exception $e) {
            $error_message = "KT Cigar Matcher diagnostic error: " . $e->getMessage();
            $this->log_debug($error_message);
            echo '<div class="notice notice-error"><p>' . esc_html($error_message) . '</p></div>';
        }
        
        // Check required tables
        global $wpdb;
        $tables_exist = true;
        $master_table = $wpdb->prefix . $this->master_table;
        $mapping_table = $wpdb->prefix . $this->mapping_table;
        $suppliers_table = $wpdb->prefix . $this->suppliers_table;
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$master_table'") != $master_table) {
            $this->log_debug("Master table '$master_table' does not exist!");
            $tables_exist = false;
        }
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$mapping_table'") != $mapping_table) {
            $this->log_debug("Mapping table '$mapping_table' does not exist!");
            $tables_exist = false;
        }
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$suppliers_table'") != $suppliers_table) {
            $this->log_debug("Suppliers table '$suppliers_table' does not exist!");
            $tables_exist = false;
        }
        
        $error_message = '';
        if (!$tables_exist) {
            $error_message = 'One or more required database tables do not exist. Please deactivate and reactivate the plugin.';
            echo '<div class="notice notice-error"><p>KT Cigar Matcher: ' . esc_html($error_message) . '</p></div>';
        }

        // Always try to detect and show errors
        $force_errors = $this->show_all_errors();
        if (!empty($force_errors)) {
            echo $force_errors;
        }
        
        // Get suppliers for dropdown
        $suppliers = $wpdb->get_results("SELECT supplier_name FROM {$wpdb->prefix}{$this->suppliers_table} ORDER BY supplier_name ASC");
        
        ?>
        <div class="wrap">
            <h1>Cigar Supplier Matcher (Enhanced)</h1>
            
            <!-- Logging toggle switch -->
           <div class="logging-toggle">

            
            <?php if (empty($data_file)): ?>
                <div class="notice notice-error">
                    <p>Error: Data file is missing or invalid. Please check the path: <?php echo esc_html($this->data_file_path); ?></p>
                </div>
            <?php else: ?>
                <div class="notice notice-success">
                    <p>Data file loaded successfully with <?php echo count($data_file['brands']['cuban'] ?? []) + count($data_file['brands']['non_cuban'] ?? []); ?> brands.</p>
                </div>
            <?php endif; ?>
            <?php if (!empty($error_message)): ?>
                <div class="notice notice-error">
                    <p>Error: <?php echo esc_html($error_message); ?></p>
                </div>
            <?php endif; ?>
			<?php 
// Debug trigger
if (isset($_GET['debug_keywords'])) {
    $debug_results = $this->debug_keyword_extraction();
    echo '<div class="notice notice-info">';
    echo '<h3>Keyword Extraction Debug:</h3>';
    echo '<p>KT_Cigar_Mappings Available: ' . ($debug_results['kt_mappings_available'] ? 'YES' : 'NO') . '</p>';
    echo '<p>Products with Keywords: ' . $debug_results['products_with_keywords'] . '/' . $debug_results['total_products'] . '</p>';
    echo '<p>Check debug log file for details: /wp-content/cigar-matcher-debug.log</p>';
    echo '</div>';
}
?>
			
<!-- ADD THIS HTML BUTTON HERE -->
<div class="debug-controls" style="margin: 15px 0; padding: 10px; background: #f9f9f9; border: 1px solid #ddd;">
    <h3>Debug Tools:</h3>
    <button type="button" class="button" id="debug-brand-comparison-btn">Debug Brand Extraction Comparison</button>
	<button type="button" class="button button-primary" id="diagnose-brand-btn">Diagnose Brand Extraction</button>
    <div id="brand-comparison-results" style="display: none; margin-top: 10px;"></div>
</div>	
			   <div class="debug-controls" style="margin: 15px 0; padding: 10px; background: #f9f9f9; border: 1px solid #ddd;">
    <h3>Debug Tools:</h3>
    <button type="button" class="button" id="check-keywords-table-btn">Check Keywords Table Status</button>
    <div id="keywords-table-results" style="display: none; margin-top: 10px;"></div>
</div>
			
            
            <div class="kt-cigar-matcher-container">
                <div class="kt-cigar-matcher-upload-section">
                    <h2>Upload Supplier CSV</h2>
                    
                    <form id="kt-cigar-csv-upload-form" enctype="multipart/form-data">
                        <?php wp_nonce_field("kt-cigar-matcher-nonce", "kt_cigar_matcher_nonce"); ?>
                        
                        <table class="form-table">
                            <tr>
                                <th><label for="supplier_name">Supplier Name:</label></th>
                                <td>
                                    <input type="text" id="supplier_name" name="supplier_name" required list="supplier-list">
                                    <datalist id="supplier-list">
                                        <?php foreach ($suppliers as $supplier): ?>
                                            <option value="<?php echo esc_attr($supplier->supplier_name); ?>">
                                        <?php endforeach; ?>
                                    </datalist>
                                    <p class="description">Enter supplier name or choose from existing suppliers</p>
                                </td>
                            </tr>
                            <tr>
                                <th><label for="supplier_csv">CSV File:</label></th>
                                <td>
                                    <input type="file" id="supplier_csv" name="supplier_csv" accept=".csv" required>
                                    <p class="description">Upload a CSV file with supplier product data</p>
                                </td>
                            </tr>
                            <tr>
                                <th><label for="batch_size">Batch Size:</label></th>
                                <td>
                                    <select id="batch_size" name="batch_size">
                                        <option value="5">5 products per batch</option>
                                        <option value="10" selected>10 products per batch</option>
                                        <option value="20">20 products per batch</option>
                                        <option value="50">50 products per batch</option>
                                    </select>
                                    <p class="description">Number of products to process in each batch</p>
                                </td>
                            </tr>
                        </table>
                        
                        <p><button type="submit" class="button button-primary" id="kt-upload-csv-btn">Upload and Process</button></p>
                    </form>
                    
                    <div id="kt-cigar-upload-messages" class="notice" style="display: none;"></div>
                </div>
                
                <!-- Keyword Categorization Legend for visual reference -->
                <div class="keyword-category-legend" style="margin: 15px 0; padding: 10px; background: #fff; border: 1px solid #ddd; border-radius: 4px; display: none;">
                    <h3>Keyword Categories:</h3>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                        <?php foreach ($this->keyword_categories as $category => $details): ?>
                            <div style="display: flex; align-items: center; margin-right: 15px;">
                                <span style="display: inline-block; width: 20px; height: 20px; background-color: <?php echo $details["color"]; ?>; margin-right: 5px; border-radius: 3px;"></span>
                                <span><?php echo $details["label"]; ?></span>
                            </div>
                        <?php endforeach; ?>
                    </div>
                </div>
                
                <!-- Processing section -->
                <div class="kt-cigar-matcher-process-section" style="display: none;">
                    <h2>Processing Supplier Products</h2>
                    
                    <div class="kt-cigar-process-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                        <div class="progress-text">0% complete</div>
                    </div>
                    
                    <div class="kt-cigar-process-stats">
                        <div>
                            <strong>Exact Matches:</strong> <span id="stats-exact">0</span>
                        </div>
                        <div>
                            <strong>Close Matches:</strong> <span id="stats-close">0</span>
                        </div>
                        <div>
                            <strong>Possible Matches:</strong> <span id="stats-possible">0</span>
                        </div>
                        <div>
                            <strong>Manual Matches:</strong> <span id="stats-manual">0</span>
                        </div>
                        <div>
                            <strong>No Matches:</strong> <span id="stats-none">0</span>
                        </div>
                    </div>
                    
                    <div id="kt-cigar-process-messages" class="notice" style="display: none;"></div>
                    
                    <div class="kt-cigar-process-results">
                        <h3>Batch Results</h3>
                        <table class="wp-list-table widefat fixed striped batch-results-table">
                            <thead>
                                <tr>
                                    <th width="10%">Product ID</th>
                                    <th width="25%">Product Title</th>
                                    <th width="15%">Match Status</th>
                                    <th width="30%">Best Match</th>
                                    <th width="20%">Keywords</th>
                                </tr>
                            </thead>
                            <tbody id="batch-results-body">
                                <!-- Results will be loaded here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="kt-cigar-actions">
                        <p>
                            <button type="button" class="button button-primary" id="kt-export-mappings-btn">Export Mappings</button>
                            <button type="button" class="button" id="kt-restart-btn">Start New CSV</button>
                        </p>
                    </div>
                </div>
                
                <!-- Manual mapping section -->
                <div class="kt-cigar-manual-map-section" style="display: none;">
                    <h2>Manual Product Mapping</h2>
                    
                    <div class="manual-map-form">
                        <div class="supplier-product-info">
                            <h3>Supplier Product</h3>
                            <div id="manual-supplier-title" class="supplier-title"></div>
                        </div>
                        
                        <div class="kt-product-search">
                            <h3>Search for KT Product</h3>
                            
                            <div class="search-form">
                                <div class="search-row">
                                    <label>By Brand:</label>
                                    <input type="text" class="search-brand-input" placeholder="Enter brand name">
                                    <button type="button" class="button search-by-brand" disabled>Search</button>
                                </div>
                                
                                <div class="search-row">
                                    <label>By SKU:</label>
                                    <input type="text" class="search-sku-input" placeholder="Enter SKU or title">
                                    <button type="button" class="button search-by-sku" disabled>Search</button>
                                </div>
                            </div>
                            
                            <div class="search-results" style="display: none;">
                                <h4>Matching KT Products</h4>
                                <table class="wp-list-table widefat fixed striped">
                                    <thead>
                                        <tr>
                                            <th width="20%">SKU</th>
                                            <th width="50%">Title</th>
                                            <th width="30%">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody class="search-results-body">
                                        <!-- Search results will be loaded here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <div class="mapping-actions">
                            <button type="button" class="button" id="cancel-manual-map">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Debug log section - for troubleshooting -->
            <?php if ($this->enable_logging && !empty($this->debug_log)): ?>
            <div class="kt-debug-log" style="margin-top: 20px; padding: 10px; background: #f8f8f8; border: 1px solid #ddd; max-height: 300px; overflow-y: auto;">
                <h3>Debug Log</h3>
                <pre><?php echo implode("\n", array_map('esc_html', $this->debug_log)); ?></pre>
            </div>
            <?php endif; ?>
        </div>
        
        <script>
			
			// Add error handling and debugging
        console.log('KT Cigar Matcher JavaScript loading...');
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, checking jQuery...');
            
            if (typeof jQuery === 'undefined') {
                console.error('jQuery not loaded yet, retrying...');
                setTimeout(function() {
                    if (typeof jQuery !== 'undefined') {
                        console.log('jQuery found, initializing...');
                        initializeMatcher();
                    } else {
                        console.error('jQuery still not available');
                    }
                }, 100);
                return;
            }
            initializeMatcher();
        });

        function initializeMatcher() {
            jQuery(document).ready(function($) {
                console.log('Matcher initialized');
                
                // Debug console logger
                function debugLog(message, data) {
                    if (typeof console !== 'undefined' && console.debug) {
                        if (data) {
                            console.debug('[KT Cigar Debug] ' + message, data);
                        } else {
                            console.debug('[KT Cigar Debug] ' + message);
                        }
                    }
                }

                // Add console logging to all AJAX requests
                $(document).ajaxSend(function(event, jqXHR, settings) {
                    debugLog('AJAX Request:', settings);
                });

                $(document).ajaxSuccess(function(event, jqXHR, settings, data) {
                    debugLog('AJAX Success:', data);
                });

                $(document).ajaxError(function(event, jqXHR, settings, error) {
                    debugLog('AJAX Error:', {
                        error: error,
                        status: jqXHR.status,
                        statusText: jqXHR.statusText,
                        responseText: jqXHR.responseText
                    });
                    
                    // Show user-friendly error
                    alert('AJAX Error: ' + error + '\nStatus: ' + jqXHR.status + '\nPlease check console for details.');
                });
                
                // Show keyword legend
                $(".keyword-category-legend").show();
                
                // FIXED: Check for errors on page load
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_check_status",
                        nonce: $("input[name='kt_cigar_matcher_nonce']").val()
                    },
                    success: function(response) {
                        if (response.success) {
                            if (response.data.has_errors) {
                                // Show error message if any
                                $(".notice.notice-error").html("<p>Error: " + response.data.message + "</p>").show();
                            }
                            // Show debug log if available
                            if (response.data.debug_log && response.data.debug_log.length > 0) {
                                debugLog('Status check debug log:', response.data.debug_log);
                            }
                        }
                    }
                });
                
                // Toggle logging
                $("#logging-toggle-switch").on("change", function() {
                    const enabled = $(this).is(":checked");
                    
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_toggle_logging",
                            nonce: $("input[name='kt_cigar_matcher_nonce']").val(),
                            enable: enabled
                        },
                        success: function(response) {
                            if (response.success) {
                                alert(response.data.message);
                                if (!enabled) {
                                    $(".kt-debug-log").hide();
                                }
                            }
                        }
                    });
                });
                
                // FIXED: Check Keywords Table Status button
                $("#check-keywords-table-btn").on("click", function() {
                    console.log('Check Keywords Table button clicked');
                    const $btn = $(this);
                    const $results = $("#keywords-table-results");
                    
                    $btn.text("Checking...").prop("disabled", true);
                    $results.html("").hide();
                    
                    const nonceValue = $("input[name='kt_cigar_matcher_nonce']").val();
                    console.log('Using nonce:', nonceValue);
                    
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_check_keywords_table",
                            nonce: nonceValue
                        },
                        success: function(response) {
                            console.log('Keywords table check response:', response);
                            $btn.text("Check Keywords Table Status").prop("disabled", false);
                            
                            if (response.success) {
                                const status = response.data.status;
                                let html = '<div class="notice notice-info"><h4>Keywords Table Status:</h4>';
                                html += '<p><strong>Exists:</strong> ' + (status.exists ? 'YES' : 'NO') + '</p>';
                                
                                if (status.exists) {
                                    html += '<p><strong>Row Count:</strong> ' + status.row_count + '</p>';
                                    html += '<p><strong>Sample SKU:</strong> ' + status.sample_sku + '</p>';
                                    html += '<p><strong>Sample Keywords Valid:</strong> ' + (status.sample_keywords_valid ? 'YES' : 'NO') + '</p>';
                                    html += '<p><strong>Sample Keywords Preview:</strong> <code>' + status.sample_keywords_preview + '</code></p>';
                                    
                                    if (!status.sample_keywords_valid) {
                                        html += '<p style="color: red;"><strong>PROBLEM:</strong> Keywords are not properly formatted JSON arrays!</p>';
                                    }
                                } else {
                                    html += '<p style="color: red;"><strong>PROBLEM:</strong> Keywords table does not exist!</p>';
                                }
                                
                                html += '</div>';
                                $results.html(html).show();
                            } else {
                                $results.html('<div class="notice notice-error"><p>Error: ' + (response.data ? response.data.message : 'Unknown error') + '</p></div>').show();
                            }
                        },
                        error: function(xhr, status, error) {
                            console.error('Keywords table check failed:', {xhr: xhr, status: status, error: error});
                            $btn.text("Check Keywords Table Status").prop("disabled", false);
                            $results.html('<div class="notice notice-error"><p>AJAX error occurred: ' + error + '</p></div>').show();
                        }
                    });
                });
                
                $("#diagnose-brand-btn").on("click", function() {
                    const $btn = $(this);
                    $btn.text("Diagnosing...").prop("disabled", true);
                    
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_diagnose_brand",
                            nonce: $("input[name='kt_cigar_matcher_nonce']").val()
                        },
                        success: function(response) {
                            $btn.text("Diagnose Brand Extraction").prop("disabled", false);
                            console.log(response.data.summary);
                            alert("Diagnosis complete! Check console and server logs for details.");
                        }
                    });
                });
                
                // Debug keywords button
                $("#debug-keywords-btn").on("click", function() {
                    const $btn = $(this);
                    const $results = $("#debug-results");
                    
                    $btn.text("Running Debug...").prop("disabled", true);
                    $results.html("").hide();
                    
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_debug_keywords",
                            nonce: $("input[name='kt_cigar_matcher_nonce']").val()
                        },
                        success: function(response) {
                            $btn.text("Debug Keyword Extraction").prop("disabled", false);
                            
                            if (response.success) {
                                const data = response.data.results;
                                let html = '<div class="notice notice-success"><h4>Debug Results:</h4>';
                                html += '<p><strong>KT_Cigar_Mappings Available:</strong> ' + (data.kt_mappings_available ? 'YES' : 'NO') + '</p>';
                                html += '<p><strong>Test Keywords Extracted:</strong> ' + data.test_keywords_extracted + '</p>';
                                html += '<p><strong>Cache Status:</strong> ' + (data.cache_was_populated ? 'Was populated (' + data.cache_product_count + ' products)' : 'Was empty') + '</p>';
                                html += '<p><strong>Products Processed:</strong> ' + data.total_products_processed + '</p>';
                                html += '<p><strong>Products with Keywords:</strong> ' + data.products_with_keywords + '/' + data.total_products_processed + '</p>';
                                html += '<p><strong>Total Keywords:</strong> ' + data.total_keywords_extracted + '</p>';
                                
                                if (data.sample_products.length > 0) {
                                    html += '<h5>Sample Products:</h5><ul>';
                                    data.sample_products.forEach(function(product) {
                                        html += '<li><strong>' + product.sku + ':</strong> ' + product.keyword_count + ' keywords - ' + JSON.stringify(product.sample_keywords) + '</li>';
                                    });
                                    html += '</ul>';
                                }
                                
                                html += '<p><em>Check debug log file for full details: /wp-content/cigar-matcher-debug.log</em></p></div>';
                                
                                $results.html(html).show();
                            } else {
                                $results.html('<div class="notice notice-error"><p>Error: ' + response.data.message + '</p></div>').show();
                            }
                        },
                        error: function() {
                            $btn.text("Debug Keyword Extraction").prop("disabled", false);
                            $results.html('<div class="notice notice-error"><p>AJAX error occurred</p></div>').show();
                        }
                    });
                });

                // Debug brand comparison button
                $("#debug-brand-comparison-btn").on("click", function() {
                    const $btn = $(this);
                    const $results = $("#brand-comparison-results");
                    
                    $btn.text("Running Comparison...").prop("disabled", true);
                    $results.html("").hide();
                    
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_debug_brand_comparison",
                            nonce: $("input[name='kt_cigar_matcher_nonce']").val()
                        },
                        success: function(response) {
                            $btn.text("Debug Brand Extraction Comparison").prop("disabled", false);
                            
                            if (response.success) {
                                $results.html('<div class="notice notice-success"><p>' + response.data.message + '</p></div>').show();
                            } else {
                                $results.html('<div class="notice notice-error"><p>Error: ' + response.data.message + '</p></div>').show();
                            }
                        },
                        error: function() {
                            $btn.text("Debug Brand Extraction Comparison").prop("disabled", false);
                            $results.html('<div class="notice notice-error"><p>AJAX error occurred</p></div>').show();
                        }
                    });
                });
                
                // Clear cache button
                $("#clear-cache-btn").on("click", function() {
                    const $btn = $(this);
                    
                    $btn.text("Clearing...").prop("disabled", true);
                    
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_clear_cache",
                            nonce: $("input[name='kt_cigar_matcher_nonce']").val()
                        },
                        success: function(response) {
                            $btn.text("Clear Product Cache").prop("disabled", false);
                            
                            if (response.success) {
                                alert(response.data.message);
                            } else {
                                alert("Error: " + response.data.message);
                            }
                        },
                        error: function() {
                            $btn.text("Clear Product Cache").prop("disabled", false);
                            alert("AJAX error occurred");
                        }
                    });
                });
                
                // Variables to store state
                let supplierProducts = [];
                let batchSize = 10;
                let processPosition = 0;
                let currentSupplierProduct = null;
                let matchCounts = {
                    exact: 0,
                    close: 0,
                    possible: 0,
                    manual: 0,
                    none: 0
                };
                    
                // FIXED: Handle CSV upload form submission
                $("#kt-cigar-csv-upload-form").on("submit", function(e) {
                    console.log('CSV form submitted');
                    e.preventDefault();
                    
                    const formData = new FormData(this);
                    formData.append("action", "kt_cigar_matcher_upload_csv");
                    
                    // Update batch size
                    batchSize = parseInt($("#batch_size").val(), 10);
                    
                    // Show loading message
                    $("#kt-cigar-upload-messages")
                        .attr("class", "notice notice-info")
                        .html("<p>Uploading and processing CSV file...</p>")
                        .show();
                    
                    // Reset stats
                    matchCounts = {
                        exact: 0,
                        close: 0,
                        possible: 0,
                        manual: 0,
                        none: 0
                    };
                    
                    $("#stats-exact").text("0");
                    $("#stats-close").text("0");
                    $("#stats-possible").text("0");
                    $("#stats-manual").text("0");
                    $("#stats-none").text("0");
                    
                    // Reset progress
                    $(".progress-fill").css("width", "0%");
                    $(".progress-text").text("0% complete");
                    processPosition = 0;
                    
                    console.log('Sending AJAX request for CSV upload');
                    
                    // Submit the form via AJAX
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: formData,
                        contentType: false,
                        processData: false,
                        success: function(response) {
                            console.log('CSV upload response:', response);
                            
                            if (response.success) {
                                // Show success message
                                $("#kt-cigar-upload-messages")
                                    .attr("class", "notice notice-success")
                                    .html("<p>" + response.data.message + "</p>")
                                    .show();
                                
                                // Switch to processing section
                                $(".kt-cigar-matcher-upload-section").hide();
                                $(".kt-cigar-matcher-process-section").show();
                                
                                // Start batch processing
                                processBatch();
                            } else {
                                // Show error message
                                $("#kt-cigar-upload-messages")
                                    .attr("class", "notice notice-error")
                                    .html("<p>Error: " + (response.data ? response.data.message : 'Unknown error') + "</p>")
                                    .show();
                            }
                        },
                        error: function(xhr, status, error) {
                            console.error('CSV upload error:', {xhr: xhr, status: status, error: error});
                            
                            // Show error message
                            $("#kt-cigar-upload-messages")
                                .attr("class", "notice notice-error")
                                .html("<p>Upload Error: " + error + "<br>Status: " + status + "<br>Please check console for details.</p>")
                                .show();
                        }
                    });
                    
                    return false;
                });
                    
                // Process batch of products
                function processBatch() {
                    // Show processing message
                    $("#kt-cigar-process-messages")
                        .attr("class", "notice notice-info")
                        .html("<p>Processing batch of products...</p>")
                        .show();
                    
                    // Submit the batch request
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_process_batch",
                            nonce: $("input[name='kt_cigar_matcher_nonce']").val(),
                            position: processPosition,
                            batch_size: batchSize
                        },
                        success: function(response) {
                            if (response.success) {
                                // Update progress
                                $(".progress-fill").css("width", response.data.percentage + "%");
                                $(".progress-text").text(response.data.percentage + "% complete");
                                
                                // Update process position
                                processPosition = response.data.position;
                                
                                // Update match counts
                                if (response.data.match_counts) {
                                    matchCounts.exact += response.data.match_counts.exact || 0;
                                    matchCounts.close += response.data.match_counts.close || 0;
                                    matchCounts.possible += response.data.match_counts.possible || 0;
                                    matchCounts.manual += response.data.match_counts.manual || 0;
                                    matchCounts.none += response.data.match_counts.none || 0;
                                    
                                    $("#stats-exact").text(matchCounts.exact);
                                    $("#stats-close").text(matchCounts.close);
                                    $("#stats-possible").text(matchCounts.possible);
                                    $("#stats-manual").text(matchCounts.manual);
                                    $("#stats-none").text(matchCounts.none);
                                }
                                
                                // Display batch results
                                displayBatchResults(response.data.batch_results);
                                
                                // Check if processing is complete
                                if (response.data.completed) {
                                    // Show completion message
                                    $("#kt-cigar-process-messages")
                                        .attr("class", "notice notice-success")
                                        .html("<p>Processing complete! " + response.data.total + " products processed.</p>")
                                        .show();
                                } else {
                                    // Process next batch
                                    processBatch();
                                }
                            } else {
                                // Show error message
                                $("#kt-cigar-process-messages")
                                    .attr("class", "notice notice-error")
                                    .html("<p>Error: " + response.data.message + "</p>")
                                    .show();
                            }
                        },
                        error: function(xhr, status, error) {
                            // Show error message
                            $("#kt-cigar-process-messages")
                                .attr("class", "notice notice-error")
                                .html("<p>Error: " + error + "</p>")
                                .show();
                        }
                    });
                }
                
                // Function to create a categorized keyword span with improved categorization
                function createCategorizedKeywordSpan(keyword, productTitle) {
                    // Clean up the keyword - remove HTML tags and normalize brackets
                    keyword = keyword.replace(/<.*?>/g, '').trim();
                    
                    // Remove comparison symbols like ≈
                    keyword = keyword.replace(/≈.*$/, '').trim();
                    
                    // Determine category based on keyword prefix
                    let category = "generic";
                    let keywordText = keyword;
                    
                    // Parse tagged keywords to get proper categorization
                    if (keyword.includes(':')) {
                        const parts = keyword.split(':');
                        const tag = parts[0].toUpperCase();
                        keywordText = parts[1].trim();
                        
                        switch (tag) {
                            case "BRAND": category = "brand"; break;
                            case "SERIES": case "MODEL": category = "model"; break;
                            case "VITOLA": category = "vitola"; break;
                            case "SPECIAL": category = "special_edition"; break;
                            case "YEAR": category = "year"; break;
                            case "COUNT": category = "count"; break;
                            case "DIM": category = "dimensions"; break;
                            case "PACK": category = "packaging"; break;
                            default: category = "generic";
                        }
                    } else {
                        // For untagged keywords, use more sophisticated pattern recognition
                        
                        // Check for year pattern (1900-2025)
                        if (/^(19|20)\d{2}$/.test(keywordText)) {
                            category = "year";
                        }
                        // Check for dimension pattern (digits with x/×)
                        else if (/\d+[xX×*\/]\d+/.test(keywordText) || /^\d+\/\d+$/.test(keywordText)) {
                            category = "dimensions";
                        }
                        // Check for counts (digits followed by count identifiers)
                        else if (/^\d+(支|×|x|pcs|个|count|ct|-count)?$/i.test(keywordText)) {
                            category = "count";
                        }
                        // Check for special edition words
                        else if (/limited|edition|special|anniversary|限量|纪念版|周年/.test(keywordText.toLowerCase())) {
                            category = "special_edition";
                        }
                        // Check for packaging
                        else if (/box|pack|tube|jar|humidor|盒|管|装/.test(keywordText.toLowerCase())) {
                            category = "packaging";
                        }
                        // Look for vitola words
                        else if (/robusto|corona|torpedo|churchill|lancero|belicoso|petit|toro|panetela/.test(keywordText.toLowerCase())) {
                            category = "vitola";
                        }
                        // Check for Chinese characters
                        else if (/[\u4e00-\u9fa5]+/.test(keywordText)) {
                            // For Chinese terms, we'll just display them as generic
                            // The server-side code will handle proper categorization with the data file
                            category = "generic";
                        }
                        // For brand context, check if this word is part of product's brand
                        else if (productTitle && keywordText.length > 2) {
                            // Extract likely brand from product title (first 1-2 words)
                            const titleWords = productTitle.split(' ').slice(0, 2).join(' ').toLowerCase();
                            if (titleWords.includes(keywordText.toLowerCase()) || 
                                keywordText.toLowerCase().includes(titleWords)) {
                                category = "brand";
                            }
                        }
                    }
                    
                    // Get color for category
                    const colors = {
                        "brand": "#e7f4ff",
                        "model": "#d4edda",
                        "vitola": "#fff3cd",
                        "special_edition": "#f8d7da",
                        "year": "#e2e3e5",
                        "count": "#d0d0ff",
                        "dimensions": "#ffd8b2",
                        "packaging": "#ddebf7",
                        "generic": "#e7e7e7"
                    };
                    
                    const labels = {
                        "brand": "Brand",
                        "model": "Series/Model",
                        "vitola": "Vitola/Size",
                        "special_edition": "Special Edition",
                        "year": "Year",
                        "count": "Count",
                        "dimensions": "Dimensions",
                        "packaging": "Packaging",
                        "generic": "Generic"
                    };
                    
                    // Create span with appropriate styling
                    return $("<span>")
                        .addClass("matched-term")
                        .css("background-color", colors[category])
                        .attr("title", labels[category])
                        .text(keywordText);
                }
                            
               // SIMPLIFIED: Display batch results - fetch DB keywords separately
function displayBatchResults(results) {
    if (!results || !results.length) {
        return;
    }
    
    // Add new results
    $.each(results, function(i, result) {
        console.log("Processing result for product:", result.product_id);
        
        let statusClass = "";
        let statusText = "";
        
        // Set status class and text
        switch (result.match_status) {
            case "exact_match":
                statusClass = "exact-match";
                statusText = "Exact Match";
                break;
            case "close_match":
                statusClass = "close-match";
                statusText = "Close Match";
                break;
            case "possible_match":
                statusClass = "possible-match";  
                statusText = "Possible Match";
                break;
            case "manual_match":
                statusClass = "manual-match";
                statusText = "Manual Match";
                break;
            default:
                statusClass = "no-match";
                statusText = "No Match";
        }
        
        // Build row
        let row = $("<tr>").addClass(statusClass);
        
        // Add columns
        row.append($("<td>").text(result.product_id));
        
        // Product title cell
        let titleCell = $("<td>").addClass("supplier-title-cell");
        titleCell.append($("<div>").addClass("supplier-title").text(result.product_title));
        // Add product image if available
if (result.product_image_url) {
    let imageDiv = $("<div>").addClass("supplier-image").css({
        "margin-top": "5px"
    });
    let img = $("<img>").attr("src", result.product_image_url).css({
        "max-width": "100px",
        "max-height": "100px",
        "cursor": "pointer"
    }).on("click", function() {
        window.open(result.product_image_url, "_blank");
    });
    imageDiv.append(img);
    titleCell.append(imageDiv);
}
		
		
		
        // Add supplier keywords container
        if (result.matched_terms && result.matched_terms.length > 0) {
            let keywordsContainer = $("<div>").addClass("product-keywords-container").css("display", "none");
            $.each(result.matched_terms, function(j, term) {
                let keywordSpan = createCategorizedKeywordSpan(term, result.product_title);
                keywordsContainer.append(keywordSpan);
            });
            titleCell.append(keywordsContainer);
        }
        
        row.append(titleCell);
        row.append($("<td>").addClass("match-status").text(statusText));
        
        // Best match column
        let bestMatchCell = $("<td>").addClass("best-match");
        if (result.best_match) {
            let matchInfoDiv = $("<div>").addClass("match-info");
            matchInfoDiv.append($("<div>").addClass("match-sku").text(result.best_match.sku));
            matchInfoDiv.append($("<div>").addClass("match-title").text(result.best_match.title));
            matchInfoDiv.append($("<div>").addClass("match-score").text("Score: " + result.best_match.score + "%"));
            
            bestMatchCell.append(matchInfoDiv);
        } else {
            bestMatchCell.text("No match found");
        }
        row.append(bestMatchCell);
        
        // Keywords cell - SIMPLIFIED APPROACH
        let keywordsCell = $("<td>").addClass("matched-terms");
        if (result.matched_terms && result.matched_terms.length > 0) {
            let termsDiv = $("<div>").addClass("matched-terms-container");
            
            // Supplier keywords section
            termsDiv.append($("<h5>").text("Supplier Keywords:").css({
                'margin': '5px 0',
                'font-weight': 'bold',
                'border-bottom': '1px solid #ddd'
            }));
            
            $.each(result.matched_terms, function(j, term) {
                let keywordSpan = createCategorizedKeywordSpan(term, result.product_title);
                termsDiv.append(keywordSpan);
            });
            
            // DB keywords section - FETCH FROM SERVER
            if (result.best_match && result.best_match.sku) {
                termsDiv.append($("<h5>").text("DB Product Keywords:").css({
                    'margin': '10px 0 5px 0',
                    'font-weight': 'bold',
                    'border-bottom': '1px solid #ddd'
                }));
                
                // Create loading placeholder
                let dbKeywordsDiv = $("<div>").addClass("db-keywords-loading")
                    .text("Loading keywords...")
                    .css({'color': '#666', 'font-style': 'italic'});
                
                termsDiv.append(dbKeywordsDiv);
                
                // FETCH keywords from server by SKU
                fetchDbKeywords(result.best_match.sku, dbKeywordsDiv, result.best_match.title);
            }
            
            keywordsCell.append(termsDiv);
        } else {
            keywordsCell.text("No keywords extracted");
        }
        row.append(keywordsCell);
        
        // Add manual mapping button
        bestMatchCell.append(
            $("<button>")
                .attr("type", "button")
                .addClass("button manual-map-btn")
                .text("Manual Map")
                .data("product-id", result.product_id)
                .data("product-title", result.product_title)
        );
        
        // Add row to table
        $("#batch-results-body").append(row);
    });
}

// NEW FUNCTION: Fetch DB keywords separately via AJAX  
function fetchDbKeywords(sku, containerDiv, productTitle) {
    $.ajax({
        url: ajaxurl,
        type: "POST",
        data: {
            action: "kt_cigar_matcher_get_db_keywords",
            nonce: $("input[name='kt_cigar_matcher_nonce']").val(),
            sku: sku
        },
        success: function(response) {
            if (response.success && response.data.keywords && response.data.keywords.length > 0) {
                // Clear loading text
                containerDiv.empty();
                
                // Add keywords
                $.each(response.data.keywords, function(j, term) {
                    let keywordSpan = createCategorizedKeywordSpan(term, productTitle);
                    containerDiv.append(keywordSpan);
                });
                
                console.log("Successfully loaded " + response.data.keywords.length + " DB keywords for SKU: " + sku);
            } else {
                containerDiv.text("No DB keywords found").css({
                    'color': '#999',
                    'font-style': 'italic'
                });
                console.log("No DB keywords found for SKU: " + sku);
            }
        },
        error: function(xhr, status, error) {
            containerDiv.text("Error loading keywords").css({
                'color': '#f00',
                'font-style': 'italic'
            });
            console.error("Error fetching DB keywords for SKU: " + sku, error);
        }
    });
}
                // Handle restart button
                $("#kt-restart-btn").on("click", function() {
                    $(".kt-cigar-matcher-process-section").hide();
                    $(".kt-cigar-matcher-upload-section").show();
                    
                    // Clear results
                    $("#batch-results-body").empty();
                });
                
                // Handle export mappings button
                $("#kt-export-mappings-btn").on("click", function() {
                    const supplier = $("#supplier_name").val();
                    
                    if (!supplier) {
                        alert("Supplier name is required for export");
                        return;
                    }
                    
                    // Show loading
                    $(this).text("Exporting...").prop("disabled", true);
                    
                    // Submit export request
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_export_mappings",
                            nonce: $("input[name='kt_cigar_matcher_nonce']").val(),
                            supplier: supplier
                        },
                        success: function(response) {
                            if (response.success) {
                                // Create download link
                                const blob = new Blob([response.data.csv], { type: "text/csv" });
                                const url = window.URL.createObjectURL(blob);
                                const a = document.createElement("a");
                                a.style.display = "none";
                                a.href = url;
                                a.download = response.data.filename;
                                
                                // Trigger download
                                document.body.appendChild(a);
                                a.click();
                                
                                // Clean up
                                window.URL.revokeObjectURL(url);
                                document.body.removeChild(a);
                                
                                // Reset button
                                $("#kt-export-mappings-btn").text("Export Mappings").prop("disabled", false);
                            } else {
                                alert("Error: " + response.data.message);
                                $("#kt-export-mappings-btn").text("Export Mappings").prop("disabled", false);
                            }
                        },
                        error: function(xhr, status, error) {
                            alert("Error: " + error);
                            $("#kt-export-mappings-btn").text("Export Mappings").prop("disabled", false);
                        }
                    });
                });
                
                // Handle manual mapping button click
                $(document).on("click", ".manual-map-btn", function() {
                    // Get product ID and title
                    const productId = $(this).data("product-id");
                    const productTitle = $(this).data("product-title");
                    
                    // Store current product for mapping
                    currentSupplierProduct = {
                        id: productId,
                        title: productTitle
                    };
                    
                    // Display product info
                    $("#manual-supplier-title").text(productTitle);
                    
                    // Show manual mapping section
                    $(".kt-cigar-matcher-process-section").hide();
                    $(".kt-cigar-manual-map-section").show();
                    
                    // Clear any previous search results
                    $(".search-results").hide();
                    $(".search-results-body").empty();
                    $(".search-brand-input").val("");
                    $(".search-sku-input").val("");
                    $(".search-by-brand").prop("disabled", true);
                    $(".search-by-sku").prop("disabled", true);
                });
                
                // Enable/disable search buttons based on input
                $(document).on("input", ".search-brand-input", function() {
                    const value = $(this).val().trim();
                    $(this).siblings(".search-by-brand").prop("disabled", value.length < 2);
                });
                
                $(document).on("input", ".search-sku-input", function() {
                    const value = $(this).val().trim();
                    $(this).siblings(".search-by-sku").prop("disabled", value.length < 2);
                });
                
                // Handle search by brand button
                $(document).on("click", ".search-by-brand", function() {
                    const brand = $(this).siblings(".search-brand-input").val().trim();
                    
                    if (brand.length < 2) {
                        return;
                    }
                    
                    // Show loading
                    $(".search-results-body").html("<tr><td colspan='3'>Searching...</td></tr>");
                    $(".search-results").show();
                    
                    // Submit search request
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_search_brand",
                            nonce: $("input[name='kt_cigar_matcher_nonce']").val(),
                            brand: brand
                        },
                        success: function(response) {
                            if (response.success) {
                                displaySearchResults(response.data.products);
                            } else {
                                $(".search-results-body").html("<tr><td colspan='3'>Error: " + response.data.message + "</td></tr>");
                            }
                        },
                        error: function(xhr, status, error) {
                            $(".search-results-body").html("<tr><td colspan='3'>Error: " + error + "</td></tr>");
                        }
                    });
                });
                
                // Handle search by SKU button
                $(document).on("click", ".search-by-sku", function() {
                    const search = $(this).siblings(".search-sku-input").val().trim();
                    
                    if (search.length < 2) {
                        return;
                    }
                    
                    // Show loading
                    $(".search-results-body").html("<tr><td colspan='3'>Searching...</td></tr>");
                    $(".search-results").show();
                    
                    // Submit search request
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_search_sku",
                            nonce: $("input[name='kt_cigar_matcher_nonce']").val(),
                            search: search
                        },
                        success: function(response) {
                            if (response.success) {
                                displaySearchResults(response.data.products);
                            } else {
                                $(".search-results-body").html("<tr><td colspan='3'>Error: " + response.data.message + "</td></tr>");
                            }
                        },
                        error: function(xhr, status, error) {
                            $(".search-results-body").html("<tr><td colspan='3'>Error: " + error + "</td></tr>");
                        }
                    });
                });
                
                // Display search results
                function displaySearchResults(products) {
                    if (!products || !products.length) {
                        $(".search-results-body").html("<tr><td colspan='3'>No matching products found</td></tr>");
                        return;
                    }
                    
                    // Clear existing results
                    $(".search-results-body").empty();
                    
                    // Add products to results
                    $.each(products, function(i, product) {
                        let row = $("<tr>");
                        
                        // Add columns
                        row.append($("<td>").text(product.sku));
                        row.append($("<td>").text(product.title));
                        
                        // Actions column with map button
                        let actionsCell = $("<td>");
                        let mapBtn = $("<button>")
                            .attr("type", "button")
                            .addClass("button button-primary quick-map-btn")
                            .text("Map to This SKU")
                            .data("sku", product.sku);
                        
                        actionsCell.append(mapBtn);
                        row.append(actionsCell);
                        
                        // Add row to table
                        $(".search-results-body").append(row);
                    });
                }
                
                // Handle quick map button click
                $(document).on("click", ".quick-map-btn", function() {
                    // Get SKU
                    const ktSku = $(this).data("sku");
                    
                    if (!currentSupplierProduct || !ktSku) {
                        alert("Error: Missing product information.");
                        return;
                    }
                    
                    // Show loading
                    $(this).text("Mapping...").prop("disabled", true);
                    
                    // Submit mapping request
                    $.ajax({
                        url: ajaxurl,
                        type: "POST",
                        data: {
                            action: "kt_cigar_matcher_quick_map",
                            nonce: $("input[name='kt_cigar_matcher_nonce']").val(),
                            supplier_id: currentSupplierProduct.id,
                            kt_sku: ktSku
                        },
                        success: function(response) {
                            if (response.success) {
                                // Update match counts
                                matchCounts.manual++;
                                $("#stats-manual").text(matchCounts.manual);
                                
                                // Show success message
                                alert("Product successfully mapped to SKU: " + ktSku);
                                
                                // Return to processing section
                                $(".kt-cigar-manual-map-section").hide();
                                $(".kt-cigar-matcher-process-section").show();
                                
                                // Update the row in the batch results table
                                updateBatchRow(currentSupplierProduct.id, ktSku, response.data.kt_title);
                            } else {
                                alert("Error: " + response.data.message);
                                $(this).text("Map to This SKU").prop("disabled", false);
                            }
                        },
                        error: function(xhr, status, error) {
                            alert("Error: " + error);
                            $(this).text("Map to This SKU").prop("disabled", false);
                        }
                    });
                });
                
                // Update batch row after manual mapping
                function updateBatchRow(productId, ktSku, ktTitle) {
                    // Find the row by product ID
                    const row = $("#batch-results-body tr").filter(function() {
                        return $(this).find("button.manual-map-btn").data("product-id") === productId;
                    });
                    
                    if (row.length) {
                        // Update row class
                        row.removeClass("no-match possible-match close-match exact-match")
                           .addClass("manual-match");
                        
                        // Update status cell
                        row.find(".match-status").text("Manual Match");
                        
                        // Update best match cell
                        row.find(".best-match").html(
                            $("<div>").addClass("match-info").append(
                                $("<div>").addClass("match-sku").text(ktSku),
                                $("<div>").addClass("match-title").text(ktTitle),
                                $("<div>").addClass("match-score").text("Score: Manual")
                            )
                        );
                    }
                }
                
                // Handle cancel manual map button
                $("#cancel-manual-map").on("click", function() {
                    // Return to processing section
                    $(".kt-cigar-manual-map-section").hide();
                    $(".kt-cigar-matcher-process-section").show();
                });
                
                // Add error handling for AJAX
                $(document).ajaxError(function(event, jqXHR, ajaxSettings, thrownError) {
                    console.error("AJAX Error:", thrownError);
                    console.error("Response:", jqXHR.responseText);
                    
                    try {
                        const response = JSON.parse(jqXHR.responseText);
                        if (response.data && response.data.message) {
                            $("#kt-cigar-upload-messages, #kt-cigar-process-messages")
                                .attr("class", "notice notice-error")
                                .html("<p>Error: " + response.data.message + "</p>")
                                .show();
                        }
                    } catch (e) {
                      $("#kt-cigar-upload-messages, #kt-cigar-process-messages")
                            .attr("class", "notice notice-error")
                            .html("<p>Error: " + (jqXHR.responseText || thrownError) + "</p>")
                            .show();
                    }
                });
            });
        }
        </script>
        
        <style>
        /* Styles for the matcher interface */
        .kt-cigar-matcher-container {
            margin-top: 20px;
        }
        
        .logging-toggle {
            margin-bottom: 15px;
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .progress-bar {
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 3px;
            margin-bottom: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #2271b1;
            width: 0%;
            transition: width 0.5s ease-in-out;
        }
        
        .kt-cigar-process-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
			margin: 10px 0;
            padding: 10px;
            border: 1px solid #eee;
            background: #f9f9f9;
        }
        
        .batch-results-table th,
        .batch-results-table td {
            padding: 8px;
        }
        
        .supplier-title {
            font-weight: 500;
        }
        
        .match-status {
            font-weight: 500;
        }
        
        .match-info {
            margin-bottom: 10px;
        }
        
        .match-sku {
            font-weight: 600;
            margin-bottom: 3px;
        }
        
        .match-score {
            font-size: 0.9em;
            color: #666;
        }
        
        /* Status colors */
        tr.exact-match .match-status {
            color: #28a745;
            font-weight: bold;
        }
        
        tr.close-match .match-status {
            color: #0d6efd;
            font-weight: bold;
        }
        
        tr.possible-match .match-status {
            color: #ffc107;
        }
        
        tr.manual-match .match-status {
            color: #6610f2;
            font-weight: bold;
        }
        
        tr.no-match .match-status {
            color: #dc3545;
        }
        
        /* Keyword styling */
        .matched-terms-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .matched-term {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            margin: 2px;
            font-size: 0.85em;
            transition: all 0.2s ease;
            color: #333;
        }
        
        .matched-term:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Enhance color contrast for better readability */
        .matched-term[title="Brand"] {
            background-color: #e7f4ff !important; 
            border-bottom: 2px solid #2196F3;
        }
        
        .matched-term[title="Series/Model"] {
            background-color: #d4edda !important;
            border-bottom: 2px solid #28a745;
        }
        
        .matched-term[title="Vitola/Size"] {
            background-color: #fff3cd !important;
            border-bottom: 2px solid #ffc107;
        }
        
        .matched-term[title="Special Edition"] {
            background-color: #f8d7da !important;
            border-bottom: 2px solid #dc3545;
        }
        
        .matched-term[title="Year"] {
            background-color: #e2e3e5 !important;
            border-bottom: 2px solid #6c757d;
        }
        
        .matched-term[title="Count"] {
            background-color: #d0d0ff !important;
            border-bottom: 2px solid #6610f2;
        }
        
        .matched-term[title="Dimensions"] {
            background-color: #ffd8b2 !important;
            border-bottom: 2px solid #fd7e14;
        }
        
        .matched-term[title="Packaging"] {
            background-color: #ddebf7 !important;
            border-bottom: 2px solid #17a2b8;
        }
        
        .matched-term[title="Generic"] {
            background-color: #e7e7e7 !important;
            border-bottom: 2px solid #adb5bd;
        }
        
        /* Manual mapping form */
        .manual-map-form {
            margin-top: 15px;
        }
        
        .supplier-product-info {
            margin-bottom: 20px;
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid #eee;
        }
        
        .search-form {
            margin-bottom: 15px;
        }
        
        .search-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        
        .search-row label {
            min-width: 80px;
        }
        
        .search-row input {
            flex-grow: 1;
            margin-right: 10px;
        }
        
        /* Product keywords container */
        .product-keywords-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
            padding: 3px;
            border-top: 1px dashed #eee;
        }
			
		/* Hybrid match results styling */
.exact-match { background-color: #d4edda; }
.close-match { background-color: #fff3cd; }
.possible-match { background-color: #f8d7da; }
.no-match { background-color: #f8f9fa; }

.score-breakdown {
    font-size: 11px;
    line-height: 1.3;
}

.hybrid-stats {
    margin: 20px 0;
    padding: 15px;
    background: #f1f1f1;
    border-radius: 5px;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 20px;
    text-align: center;
}

.stat-item {
    padding: 10px;
    background: white;
    border-radius: 3px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.stat-number {
    font-size: 24px;
    font-weight: bold;
    color: #0073aa;
}

.stat-label {
    font-size: 12px;
    color: #666;
    text-transform: uppercase;
}	
			
			
			
			
			
			
        </style>
        <?php
    }
    
    /**
     * Display debug page
     */
    public function display_debug_page() {
        // Get page parameters
        $current_page = isset($_GET["paged"]) ? intval($_GET["paged"]) : 1;
        $brand_filter = isset($_GET["brand"]) ? sanitize_text_field($_GET["brand"]) : "";
        $sku_filter = isset($_GET["sku"]) ? sanitize_text_field($_GET["sku"]) : "";
        $title_filter = isset($_GET["title"]) ? sanitize_text_field($_GET["title"]) : "";
        
        // Get products from database
        $per_page = 50;
        $products = $this->get_database_products($current_page, $per_page, $brand_filter, $sku_filter, $title_filter);
        
        // Get brands for filter
        $brands = $this->get_unique_brands();
        
        // Get total pages
        $total_products = $this->count_database_products($brand_filter, $sku_filter, $title_filter);
        $total_pages = ceil($total_products / $per_page);
        
        // Load data file
        $data_file = $this->load_data_file();
        ?>
        <div class="wrap">
            <h1>Cigar Keyword Debug</h1>
            
            <?php if (empty($data_file)): ?>
                <div class="notice notice-error">
                    <p>Error: Data file is missing or invalid. Please check the path: <?php echo esc_html($this->data_file_path); ?></p>
                </div>
            <?php else: ?>
                <div class="notice notice-success">
                    <p>Data file loaded successfully with <?php echo count($data_file['brands']['cuban'] ?? []) + count($data_file['brands']['non_cuban'] ?? []); ?> brands.</p>
                </div>
            <?php endif; ?>
            
            <div class="keyword-category-legend" style="margin: 15px 0; padding: 10px; background: #fff; border: 1px solid #ddd; border-radius: 4px;">
                <h3>Keyword Categories:</h3>
                <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                    <?php foreach ($this->keyword_categories as $category => $details): ?>
                        <div style="display: flex; align-items: center; margin-right: 15px;">
                            <span style="display: inline-block; width: 20px; height: 20px; background-color: <?php echo $details["color"]; ?>; margin-right: 5px; border-radius: 3px;"></span>
                            <span><?php echo $details["label"]; ?></span>
                        </div>
                    <?php endforeach; ?>
                </div>
            </div>
            
            <div class="tablenav top">
                <form method="get">
                    <input type="hidden" name="page" value="<?php echo esc_attr($this->plugin_slug . "-debug"); ?>">
                    
                    <div class="alignleft actions">
                        <select name="brand">
                            <option value="">All Brands</option>
                            <?php foreach ($brands as $brand): ?>
                                <option value="<?php echo esc_attr($brand); ?>" <?php selected($brand_filter, $brand); ?>><?php echo esc_html($brand); ?></option>
                            <?php endforeach; ?>
                        </select>
                        
                        <input type="text" name="sku" placeholder="SKU contains..." value="<?php echo esc_attr($sku_filter); ?>">
                        <input type="text" name="title" placeholder="Title contains..." value="<?php echo esc_attr($title_filter); ?>">
                        
                        <input type="submit" class="button" value="Filter">
                        <?php if (!empty($brand_filter) || !empty($sku_filter) || !empty($title_filter)): ?>
                            <a href="?page=<?php echo esc_attr($this->plugin_slug . "-debug"); ?>" class="button">Reset</a>
                        <?php endif; ?>
                    </div>
                </form>
                
                <div class="tablenav-pages">
                    <span class="displaying-num"><?php echo number_format($total_products); ?> items</span>
                    <span class="pagination-links">
                        <?php if ($current_page > 1): ?>
                            <a class="prev-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-debug"); ?>&paged=<?php echo $current_page - 1; ?>&brand=<?php echo esc_attr($brand_filter); ?>&sku=<?php echo esc_attr($sku_filter); ?>&title=<?php echo esc_attr($title_filter); ?>">‹</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">‹</span>
                        <?php endif; ?>
                        
                        <span class="paging-input">
                            <?php echo $current_page; ?> of <span class="total-pages"><?php echo $total_pages; ?></span>
                        </span>
                        
                        <?php if ($current_page < $total_pages): ?>
                            <a class="next-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-debug"); ?>&paged=<?php echo $current_page + 1; ?>&brand=<?php echo esc_attr($brand_filter); ?>&sku=<?php echo esc_attr($sku_filter); ?>&title=<?php echo esc_attr($title_filter); ?>">›</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">›</span>
                        <?php endif; ?>
                    </span>
                </div>
                <br class="clear">
            </div>
            
            <div class="supplier-debug-tool">
                <h2>Test Product Title Analysis</h2>
                <form method="post" action="">
                    <p>
                        <label for="test_title">Product Title:</label><br>
                        <input type="text" name="test_title" id="test_title" style="width: 50%;" value="<?php echo isset($_POST["test_title"]) ? esc_attr($_POST["test_title"]) : ""; ?>">
                    </p>
                    <p>
                        <label for="test_dimensions">Dimensions (e.g. 50/124):</label><br>
                        <input type="text" name="test_dimensions" id="test_dimensions" value="<?php echo isset($_POST["test_dimensions"]) ? esc_attr($_POST["test_dimensions"]) : ""; ?>">
                    </p>
                    <p>
                        <input type="submit" class="button button-primary" value="Analyze Title">
                    </p>
                </form>
                
                <?php if (isset($_POST["test_title"])): ?>
                    <?php
                    $test_title = sanitize_text_field($_POST["test_title"]);
                    $test_dimensions = isset($_POST["test_dimensions"]) ? sanitize_text_field($_POST["test_dimensions"]) : "";
                    
                    // Use KT_Cigar_Mappings for processing if available
                    if (class_exists('KT_Cigar_Mappings')) {
                        $processed_product = KT_Cigar_Mappings::process_supplier_product($test_title, $test_dimensions);
                    } else {
                        // Fallback to our own method
                        $processed_product = $this->process_product_title_enhanced($test_title, $test_dimensions);
                    }
                    ?>
                    <div class="supplier-results" style="margin-top: 20px; padding: 15px; background: #f9f9f9; border: 1px solid #ddd;">
                        <h3>Title Analysis: <?php echo esc_html($test_title); ?></h3>
                        <table class="wp-list-table widefat fixed">
                            <tr>
                                <th width="200">Property</th>
                                <th>Value</th>
                            </tr>
                            <tr>
                                <td>Brand:</td>
                                <td><?php echo esc_html($processed_product["brand"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Series/Model:</td>
                                <td><?php echo esc_html($processed_product["model"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Vitola:</td>
                                <td><?php echo esc_html($processed_product["vitola"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Year:</td>
                                <td><?php echo esc_html($processed_product["year"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Special Edition:</td>
                                <td><?php echo esc_html($processed_product["special_edition"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Count:</td>
                                <td><?php echo esc_html($processed_product["count"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Ring Gauge:</td>
                                <td><?php echo esc_html($processed_product["dimension_info"]["ring_gauge"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Length:</td>
                                <td><?php echo esc_html($processed_product["dimension_info"]["length"] ?: "Not detected"); ?></td>
                            </tr>
                            <tr>
                                <td>Extracted Keywords:</td>
                                <td>
                                    <?php if (!empty($processed_product["keywords"])): ?>
                                        <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                                            <?php 
                                            // Display each keyword with its categories
                                            foreach ($processed_product["keywords"] as $keyword): 
                                                echo $this->display_categorized_keyword($keyword, $processed_product, $data_file);
                                            ?>
                                            <?php endforeach; ?>
                                        </div>
                                    <?php else: ?>
                                        No keywords extracted
                                    <?php endif; ?>
                                </td>
                            </tr>
                        </table>
                    </div>
                <?php endif; ?>
            </div>
            
            <h2>Database Products</h2>
            
            <table class="wp-list-table widefat fixed striped">
                <thead>
                    <tr>
                        <th width="15%">SKU</th>
                        <th width="15%">Brand</th>
                        <th width="20%">Title</th>
                        <th width="10%">Dimensions</th>
                        <th width="40%">Extracted Keywords</th>
                    </tr>
                </thead>
                <tbody>
                    <?php if (empty($products)): ?>
                        <tr>
                            <td colspan="5">No products found</td>
                        </tr>
                    <?php else: ?>
                        <?php foreach ($products as $product): 
                            // Extract dimensions
                            $dimensions = "";
                            if (!empty($product->seat_row) || !empty($product->seat_number)) {
                               $dimensions = (!empty($product->seat_row) ? $product->seat_row : "") . "/" . 
                                           (!empty($product->seat_number) ? $product->seat_number : "");
                            }
                            
                            // Process product to extract keywords
                            if (class_exists('KT_Cigar_Mappings')) {
                                $processed_product = KT_Cigar_Mappings::process_internal_product(
                                    $product->sku,
                                    $product->product_title,
                                    $dimensions
                                );
                            } else {
                                $processed_product = $this->process_product_title_enhanced(
                                    $product->product_title,
                                    $dimensions
                                );
                            }
                            $keywords = $processed_product["keywords"] ?? array();
                        ?>
                            <tr>
                                <td><?php echo esc_html($product->sku); ?></td>
                                <td><?php echo esc_html($product->brand); ?></td>
                                <td><?php echo esc_html($product->product_title); ?></td>
                                <td><?php echo esc_html($dimensions); ?></td>
                                <td>
                                    <?php if (!empty($keywords)): ?>
                                        <div style="display: flex; flex-wrap: wrap; gap: 5px; max-height: 100px; overflow-y: auto;">
                                            <?php 
                                            // Display each keyword with its categories
                                            foreach ($keywords as $keyword): 
                                                echo $this->display_categorized_keyword($keyword, $processed_product, $data_file);
                                            ?>
                                            <?php endforeach; ?>
                                        </div>
                                    <?php else: ?>
                                        No keywords extracted
                                    <?php endif; ?>
                                </td>
                            </tr>
                        <?php endforeach; ?>
                    <?php endif; ?>
                </tbody>
            </table>
            
            <div class="tablenav bottom">
                <div class="tablenav-pages">
                    <span class="displaying-num"><?php echo number_format($total_products); ?> items</span>
                    <span class="pagination-links">
                        <?php if ($current_page > 1): ?>
                            <a class="prev-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-debug"); ?>&paged=<?php echo $current_page - 1; ?>&brand=<?php echo esc_attr($brand_filter); ?>&sku=<?php echo esc_attr($sku_filter); ?>&title=<?php echo esc_attr($title_filter); ?>">‹</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">‹</span>
                        <?php endif; ?>
                        
                        <span class="paging-input">
                            <?php echo $current_page; ?> of <span class="total-pages"><?php echo $total_pages; ?></span>
                        </span>
                        
                        <?php if ($current_page < $total_pages): ?>
                            <a class="next-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-debug"); ?>&paged=<?php echo $current_page + 1; ?>&brand=<?php echo esc_attr($brand_filter); ?>&sku=<?php echo esc_attr($sku_filter); ?>&title=<?php echo esc_attr($title_filter); ?>">›</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">›</span>
                        <?php endif; ?>
                    </span>
                </div>
            </div>
        </div>
        <?php
    }
	/**
     * Display mappings page
     */
    public function display_mappings_page() {
        // Get page parameters
        $current_page = isset($_GET["paged"]) ? intval($_GET["paged"]) : 1;
        $supplier_filter = isset($_GET["supplier"]) ? sanitize_text_field($_GET["supplier"]) : "";
        $confidence_filter = isset($_GET["confidence"]) ? sanitize_text_field($_GET["confidence"]) : "";
        $search_filter = isset($_GET["search"]) ? sanitize_text_field($_GET["search"]) : "";
        
        // Get mappings per page
        $per_page = 30;
        
        // Get suppliers for filter
        global $wpdb;
        $suppliers = $wpdb->get_col("SELECT DISTINCT supplier_name FROM {$wpdb->prefix}{$this->mapping_table} ORDER BY supplier_name ASC");
        
        // Get total mappings count
        $total_mappings = $this->count_mappings($supplier_filter, $confidence_filter, $search_filter);
        $total_pages = ceil($total_mappings / $per_page);
        
        // Get mappings for current page
        $mappings = $this->get_mappings($current_page, $per_page, $supplier_filter, $confidence_filter, $search_filter);
        
        ?>
        <div class="wrap">
            <h1>Supplier Mappings</h1>
            
            <div class="tablenav top">
                <form method="get">
                    <input type="hidden" name="page" value="<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>">
                    
                    <div class="alignleft actions">
                        <select name="supplier">
                            <option value="">All Suppliers</option>
                            <?php foreach ($suppliers as $supplier): ?>
                                <option value="<?php echo esc_attr($supplier); ?>" <?php selected($supplier_filter, $supplier); ?>><?php echo esc_html($supplier); ?></option>
                            <?php endforeach; ?>
                        </select>
                        
                        <select name="confidence">
                            <option value="">All Confidence Levels</option>
                            <option value="exact" <?php selected($confidence_filter, "exact"); ?>>Exact Matches</option>
                            <option value="close" <?php selected($confidence_filter, "close"); ?>>Close Matches</option>
                            <option value="possible" <?php selected($confidence_filter, "possible"); ?>>Possible Matches</option>
                            <option value="manual" <?php selected($confidence_filter, "manual"); ?>>Manual Matches</option>
                        </select>
                        
                        <input type="text" name="search" placeholder="Search..." value="<?php echo esc_attr($search_filter); ?>">
                        
                        <input type="submit" class="button" value="Filter">
                        <?php if (!empty($supplier_filter) || !empty($confidence_filter) || !empty($search_filter)): ?>
                            <a href="?page=<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>" class="button">Reset</a>
                        <?php endif; ?>
                    </div>
                </form>
                
                <div class="tablenav-pages">
                    <span class="displaying-num"><?php echo number_format($total_mappings); ?> items</span>
                    <span class="pagination-links">
                        <?php if ($current_page > 1): ?>
                            <a class="prev-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>&paged=<?php echo $current_page - 1; ?>&supplier=<?php echo esc_attr($supplier_filter); ?>&confidence=<?php echo esc_attr($confidence_filter); ?>&search=<?php echo esc_attr($search_filter); ?>">‹</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">‹</span>
                        <?php endif; ?>
                        
                        <span class="paging-input">
                            <?php echo $current_page; ?> of <span class="total-pages"><?php echo $total_pages; ?></span>
                        </span>
                        
                        <?php if ($current_page < $total_pages): ?>
                            <a class="next-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>&paged=<?php echo $current_page + 1; ?>&supplier=<?php echo esc_attr($supplier_filter); ?>&confidence=<?php echo esc_attr($confidence_filter); ?>&search=<?php echo esc_attr($search_filter); ?>">›</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">›</span>
                        <?php endif; ?>
                    </span>
                </div>
                <br class="clear">
            </div>
            
            <table class="wp-list-table widefat fixed striped">
                <thead>
                    <tr>
                        <th width="15%">Supplier</th>
                        <th width="10%">Supplier ID</th>
                        <th width="20%">Supplier Title</th>
                        <th width="10%">KT SKU</th>
                        <th width="10%">Confidence</th>
                        <th width="25%">Matched Terms</th>
                        <th width="10%">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <?php if (empty($mappings)): ?>
                        <tr>
                            <td colspan="7">No mappings found</td>
                        </tr>
                    <?php else: ?>
                        <?php foreach ($mappings as $mapping): ?>
                            <tr>
                                <td><?php echo esc_html($mapping->supplier_name); ?></td>
                                <td><?php echo esc_html($mapping->supplier_id); ?></td>
                                <td><?php echo esc_html($mapping->supplier_title); ?></td>
                                <td><?php echo esc_html($mapping->kt_sku); ?></td>
                                <td>
                                    <?php 
                                    $confidence_class = "";
                                    switch ($mapping->match_confidence) {
                                        case "exact": $confidence_class = "exact-match"; break;
                                        case "close": $confidence_class = "close-match"; break;
                                        case "possible": $confidence_class = "possible-match"; break;
                                        case "manual": $confidence_class = "manual-match"; break;
                                        default: $confidence_class = "no-match";
                                    }
                                    ?>
                                    <span class="<?php echo $confidence_class; ?>-text"><?php echo ucfirst(esc_html($mapping->match_confidence)); ?></span>
                                </td>
                                <td>
                                    <?php if (!empty($mapping->matched_terms)): ?>
                                        <div class="matched-terms-list">
                                            <?php 
                                            $terms = explode(",", $mapping->matched_terms);
                                            $data_file = $this->load_data_file();
                                            
                                            foreach ($terms as $term) {
                                                $term = trim($term);
                                                // Process product to get category info 
                                                $processed_product = array();
                                                if (class_exists('KT_Cigar_Mappings')) {
                                                    // Use KT_Cigar_Mappings for processing
                                                    $processed_product = KT_Cigar_Mappings::process_supplier_product($term);
                                                } else {
                                                    // Use our own method
                                                    $processed_product = $this->process_product_title_enhanced($term);
                                                }
                                                
                                                echo $this->display_categorized_keyword($term, $processed_product, $data_file);
                                            }
                                            ?>
                                        </div>
                                    <?php else: ?>
                                        <em>No matched terms</em>
                                    <?php endif; ?>
                                </td>
                                <td>
                                    <button type="button" class="button delete-mapping-btn" data-id="<?php echo $mapping->id; ?>">Delete</button>
                                </td>
                            </tr>
                        <?php endforeach; ?>
                    <?php endif; ?>
                </tbody>
            </table>
            
            <div class="tablenav bottom">
                <div class="tablenav-pages">
                    <span class="displaying-num"><?php echo number_format($total_mappings); ?> items</span>
                    <span class="pagination-links">
                        <?php if ($current_page > 1): ?>
                            <a class="prev-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>&paged=<?php echo $current_page - 1; ?>&supplier=<?php echo esc_attr($supplier_filter); ?>&confidence=<?php echo esc_attr($confidence_filter); ?>&search=<?php echo esc_attr($search_filter); ?>">‹</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">‹</span>
                        <?php endif; ?>
                        
                        <span class="paging-input">
                            <?php echo $current_page; ?> of <span class="total-pages"><?php echo $total_pages; ?></span>
                        </span>
                        
                        <?php if ($current_page < $total_pages): ?>
                            <a class="next-page button" href="?page=<?php echo esc_attr($this->plugin_slug . "-mappings"); ?>&paged=<?php echo $current_page + 1; ?>&supplier=<?php echo esc_attr($supplier_filter); ?>&confidence=<?php echo esc_attr($confidence_filter); ?>&search=<?php echo esc_attr($search_filter); ?>">›</a>
                        <?php else: ?>
                            <span class="tablenav-pages-navspan button disabled">›</span>
                        <?php endif; ?>
                    </span>
                </div>
            </div>
        </div>
        
        <script>
document.addEventListener('DOMContentLoaded', function() {
    if (typeof jQuery === 'undefined') {
        setTimeout(function() {
            if (typeof jQuery !== 'undefined') {
                initializeMappings();
            }
        }, 100);
        return;
    }
    initializeMappings();
});

function initializeMappings() {
    jQuery(document).ready(function($) {
        // Delete mapping button
        $(".delete-mapping-btn").on("click", function() {
            if (confirm("Are you sure you want to delete this mapping?")) {
                const mappingId = $(this).data("id");
                
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_delete_mapping",
                        nonce: "<?php echo wp_create_nonce("kt-cigar-matcher-nonce"); ?>",
                        mapping_id: mappingId
                    },
                    success: function(response) {
                        if (response.success) {
                            alert("Mapping deleted successfully");
                            location.reload();
                        } else {
                            alert("Error: " + response.data.message);
                        }
                    },
                    error: function(xhr, status, error) {
                        alert("Error: " + error);
                    }
                });
            }
        });
    });
}
</script>
        
        <style>
        .matched-terms-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .exact-match-text {
            color: #28a745;
            font-weight: bold;
        }
        
        .close-match-text {
            color: #0d6efd;
            font-weight: bold;
        }
        
        .possible-match-text {
            color: #ffc107;
        }
        
        .manual-match-text {
            color: #6610f2;
            font-weight: bold;
        }
        
        .no-match-text {
            color: #dc3545;
        }
        </style>
        <?php
    }
    
    /**
     * Display templates page
     */
    public function display_templates_page() {
        // Get templates
        global $wpdb;
        $templates = $wpdb->get_results("SELECT * FROM {$wpdb->prefix}{$this->template_table} ORDER BY template_name ASC");
        
        ?>
        <div class="wrap">
            <h1>CSV Templates</h1>
            
            <div class="template-form-container">
                <h2>Create New Template</h2>
                
                <form id="kt-cigar-template-form">
                    <?php wp_nonce_field("kt-cigar-matcher-nonce", "kt_cigar_matcher_nonce"); ?>
                    
                    <input type="hidden" name="template_id" id="template_id" value="">
                    
                    <table class="form-table">
                        <tr>
                            <th><label for="template_name">Template Name:</label></th>
                            <td>
                                <input type="text" id="template_name" name="template_name" required>
                                <p class="description">Enter a unique name for this template</p>
                            </td>
                        </tr>
                        <tr>
                            <th><label for="supplier_name">Supplier Name:</label></th>
                            <td>
                                <input type="text" id="supplier_name" name="supplier_name" required>
                                <p class="description">Enter the supplier name for this template</p>
                            </td>
                        </tr>
                    </table>
                    
                    <h3>Column Mappings</h3>
                    <p class="description">Map supplier CSV columns to KT Cigar fields</p>
                    
                    <table class="wp-list-table widefat fixed" id="column-mappings-table">
                        <thead>
                            <tr>
                                <th width="40%">Supplier CSV Column</th>
                                <th width="40%">KT Cigar Field</th>
                                <th width="20%">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <input type="text" name="csv_columns[]" class="regular-text" required>
                                </td>
                                <td>
                                    <select name="kt_fields[]" required>
                                        <option value="">-- Select Field --</option>
                                        <option value="id">Product ID</option>
                                        <option value="title">Product Title</option>
                                        <option value="brand">Brand</option>
                                        <option value="model">Model/Series</option>
                                        <option value="ring_gauge">Ring Gauge</option>
                                        <option value="length">Length</option>
                                        <option value="price">Price</option>
                                        <option value="description">Description</option>
                                        <option value="stock">Stock</option>
                                        <option value="skip">Skip (Ignore this column)</option>
                                    </select>
                                </td>
                                <td>
                                    <button type="button" class="button remove-mapping-row">Remove</button>
                                </td>
                            </tr>
                        </tbody>
                        <tfoot>
                            <tr>
                                <td colspan="3">
                                    <button type="button" class="button" id="add-mapping-row">Add Column Mapping</button>
                                </td>
                            </tr>
                        </tfoot>
                    </table>
                    
                    <p class="submit">
                        <button type="submit" class="button button-primary" id="save-template-btn">Save Template</button>
                        <button type="button" class="button" id="cancel-edit-btn" style="display: none;">Cancel Edit</button>
                    </p>
                </form>
            </div>
            
            <h2>Saved Templates</h2>
            
            <table class="wp-list-table widefat fixed striped">
                <thead>
                    <tr>
                        <th width="25%">Template Name</th>
                        <th width="20%">Supplier</th>
                        <th width="30%">Column Mappings</th>
                        <th width="15%">Created</th>
                        <th width="10%">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <?php if (empty($templates)): ?>
                        <tr>
                            <td colspan="5">No templates found</td>
                        </tr>
                    <?php else: ?>
                        <?php foreach ($templates as $template): 
                            $column_mappings = json_decode($template->column_mappings, true);
                        ?>
                            <tr>
                                <td><?php echo esc_html($template->template_name); ?></td>
                                <td><?php echo esc_html($template->supplier_name); ?></td>
                                <td>
                                    <?php if (!empty($column_mappings)): ?>
                                        <div class="column-mappings-preview">
                                            <?php 
                                            foreach ($column_mappings as $mapping) {
                                                echo esc_html($mapping["csv_column"] . " → " . $mapping["kt_field"]) . "<br>";
                                            }
                                            ?>
                                        </div>
                                    <?php else: ?>
                                        <em>No mappings defined</em>
                                    <?php endif; ?>
                                </td>
                                <td><?php echo date("Y-m-d", strtotime($template->created_at)); ?></td>
                                <td>
                                    <button type="button" class="button edit-template-btn" data-id="<?php echo $template->id; ?>">Edit</button>
                                    <button type="button" class="button delete-template-btn" data-id="<?php echo $template->id; ?>">Delete</button>
                                </td>
                            </tr>
                        <?php endforeach; ?>
                    <?php endif; ?>
                </tbody>
            </table>
        </div>
        
        <script>
document.addEventListener('DOMContentLoaded', function() {
    if (typeof jQuery === 'undefined') {
        setTimeout(function() {
            if (typeof jQuery !== 'undefined') {
                initializeTemplates();
            }
        }, 100);
        return;
    }
    initializeTemplates();
});

function initializeTemplates() {
    jQuery(document).ready(function($) {
        // Add mapping row
        $("#add-mapping-row").on("click", function() {
            const row = `
            <tr>
                <td>
                    <input type="text" name="csv_columns[]" class="regular-text" required>
                </td>
                <td>
                    <select name="kt_fields[]" required>
                        <option value="">-- Select Field --</option>
                        <option value="id">Product ID</option>
                        <option value="title">Product Title</option>
                        <option value="brand">Brand</option>
                        <option value="model">Model/Series</option>
                        <option value="ring_gauge">Ring Gauge</option>
                        <option value="length">Length</option>
                        <option value="price">Price</option>
                        <option value="description">Description</option>
                        <option value="stock">Stock</option>
                        <option value="skip">Skip (Ignore this column)</option>
                    </select>
                </td>
                <td>
                    <button type="button" class="button remove-mapping-row">Remove</button>
                </td>
            </tr>
            `;
            
            $("#column-mappings-table tbody").append(row);
        });
        
        // Remove mapping row
        $(document).on("click", ".remove-mapping-row", function() {
            const rowCount = $("#column-mappings-table tbody tr").length;
            
            if (rowCount > 1) {
                $(this).closest("tr").remove();
            } else {
                alert("You must have at least one column mapping");
            }
        });
        
        // Save template
        $("#kt-cigar-template-form").on("submit", function(e) {
            e.preventDefault();
            
            // Validate form
            const templateName = $("#template_name").val().trim();
            const supplierName = $("#supplier_name").val().trim();
            
            if (!templateName || !supplierName) {
                alert("Template name and supplier name are required");
                return;
            }
            
            // Get column mappings
            const columnMappings = [];
            
            $("#column-mappings-table tbody tr").each(function() {
                const csvColumn = $(this).find("input[name='csv_columns[]']").val().trim();
                const ktField = $(this).find("select[name='kt_fields[]']").val();
                
                if (csvColumn && ktField) {
                    columnMappings.push({
                        csv_column: csvColumn,
                        kt_field: ktField
                    });
                }
            });
            
            if (columnMappings.length === 0) {
                alert("You must define at least one column mapping");
                return;
            }
            
            // Get template ID (if editing)
            const templateId = $("#template_id").val();
            
            // Show loading
            $("#save-template-btn").text("Saving...").prop("disabled", true);
            
            // Submit request
            $.ajax({
                url: ajaxurl,
                type: "POST",
                data: {
                    action: "kt_cigar_matcher_save_template",
                    nonce: $("#kt_cigar_matcher_nonce").val(),
                    template_id: templateId,
                    template_name: templateName,
                    supplier_name: supplierName,
                    column_mappings: JSON.stringify(columnMappings)
                },
                success: function(response) {
                    if (response.success) {
                        alert("Template saved successfully");
                        location.reload();
                    } else {
                        alert("Error: " + response.data.message);
                        $("#save-template-btn").text("Save Template").prop("disabled", false);
                    }
                },
                error: function(xhr, status, error) {
                    alert("Error: " + error);
                    $("#save-template-btn").text("Save Template").prop("disabled", false);
                }
            });
        });
        
        // Edit template
        $(".edit-template-btn").on("click", function() {
            const templateId = $(this).data("id");
            
            // Show loading
            $(this).text("Loading...").prop("disabled", true);
            
            // Submit request
            $.ajax({
                url: ajaxurl,
                type: "POST",
                data: {
                    action: "kt_cigar_matcher_load_template",
                    nonce: $("#kt_cigar_matcher_nonce").val(),
                    template_id: templateId
                },
                success: function(response) {
                    if (response.success) {
                        // Populate form
                        $("#template_id").val(response.data.id);
                        $("#template_name").val(response.data.template_name);
                        $("#supplier_name").val(response.data.supplier_name);
                        
                        // Clear existing rows
                        $("#column-mappings-table tbody").empty();
                        
                        // Add mapping rows
                        const columnMappings = JSON.parse(response.data.column_mappings);
                        
                        columnMappings.forEach(function(mapping) {
                            const row = `
                            <tr>
                                <td>
                                    <input type="text" name="csv_columns[]" class="regular-text" value="${mapping.csv_column}" required>
                                </td>
                                <td>
                                    <select name="kt_fields[]" required>
                                        <option value="">-- Select Field --</option>
                                        <option value="id" ${mapping.kt_field === "id" ? "selected" : ""}>Product ID</option>
                                        <option value="title" ${mapping.kt_field === "title" ? "selected" : ""}>Product Title</option>
                                        <option value="brand" ${mapping.kt_field === "brand" ? "selected" : ""}>Brand</option>
                                        <option value="model" ${mapping.kt_field === "model" ? "selected" : ""}>Model/Series</option>
                                        <option value="ring_gauge" ${mapping.kt_field === "ring_gauge" ? "selected" : ""}>Ring Gauge</option>
                                        <option value="length" ${mapping.kt_field === "length" ? "selected" : ""}>Length</option>
                                        <option value="price" ${mapping.kt_field === "price" ? "selected" : ""}>Price</option>
                                        <option value="description" ${mapping.kt_field === "description" ? "selected" : ""}>Description</option>
                                        <option value="stock" ${mapping.kt_field === "stock" ? "selected" : ""}>Stock</option>
                                        <option value="skip" ${mapping.kt_field === "skip" ? "selected" : ""}>Skip (Ignore this column)</option>
                                    </select>
                                </td>
                                <td>
                                    <button type="button" class="button remove-mapping-row">Remove</button>
                                </td>
                            </tr>
                            `;
                            
                            $("#column-mappings-table tbody").append(row);
                        });
                        
                        // Show cancel button
                        $("#save-template-btn").text("Update Template");
                        $("#cancel-edit-btn").show();
                        
                        // Scroll to form
                        $("html, body").animate({
                            scrollTop: $(".template-form-container").offset().top
                        }, 500);
                        
                        $(".edit-template-btn").text("Edit").prop("disabled", false);
                    } else {
                        alert("Error: " + response.data.message);
                        $(".edit-template-btn").text("Edit").prop("disabled", false);
                    }
                },
                error: function(xhr, status, error) {
                    alert("Error: " + error);
                    $(".edit-template-btn").text("Edit").prop("disabled", false);
                }
            });
        });
        
        // Cancel edit
        $("#cancel-edit-btn").on("click", function() {
            // Clear form
            $("#template_id").val("");
            $("#template_name").val("");
            $("#supplier_name").val("");
            
            // Clear existing rows
            $("#column-mappings-table tbody").empty();
            
            // Add default row
            $("#add-mapping-row").trigger("click");
            
            // Hide cancel button
            $("#save-template-btn").text("Save Template");
            $("#cancel-edit-btn").hide();
        });
        
        // Delete template
        $(".delete-template-btn").on("click", function() {
            if (confirm("Are you sure you want to delete this template?")) {
                const templateId = $(this).data("id");
                
                // Show loading
                $(this).text("Deleting...").prop("disabled", true);
                
                // Submit request
                $.ajax({
                    url: ajaxurl,
                    type: "POST",
                    data: {
                        action: "kt_cigar_matcher_delete_template",
                        nonce: $("#kt_cigar_matcher_nonce").val(),
                        template_id: templateId
                    },
                    success: function(response) {
                        if (response.success) {
                            alert("Template deleted successfully");
                            location.reload();
                        } else {
                            alert("Error: " + response.data.message);
                            $(".delete-template-btn").text("Delete").prop("disabled", false);
                        }
                    },
                    error: function(xhr, status, error) {
                        alert("Error: " + error);
                        $(".delete-template-btn").text("Delete").prop("disabled", false);
                    }
                });
            }
        });
        
        // Initialize with one row
        if ($("#column-mappings-table tbody tr").length === 0) {
            $("#add-mapping-row").trigger("click");
        }
    });
}
</script>
        
        <style>
        .template-form-container {
            margin-bottom: 30px;
            padding: 15px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .column-mappings-preview {
            max-height: 100px;
            overflow-y: auto;
        }
        </style>
        <?php
    }
    /**
 * ADDITIONAL: Check if brands are the same (PUBLIC method for main plugin)
 */
public static function is_same_brand($brand1, $brand2) {
    self::init();
    
    if (mb_strtolower($brand1) === mb_strtolower($brand2)) {
        return true;
    }
    
    // Get main brands and compare
    $main_brand1 = self::getMainBrandFromDataFile($brand1);
    $main_brand2 = self::getMainBrandFromDataFile($brand2);
    
    return $main_brand1 && $main_brand2 && mb_strtolower($main_brand1) === mb_strtolower($main_brand2);
}

/**
 * ADDITIONAL: Get data file for external access
 */
public static function get_data_file() {
    self::init();
    return self::$data_file;
}

/**
 * ADDITIONAL: Categorize keyword (required by main plugin)
 */
public static function categorize_keyword($keyword, $product = null) {
    // Parse tagged keywords
    if (preg_match('/^([A-Z_]+):(.+)$/i', $keyword, $matches)) {
        $tag = strtoupper($matches[1]);
        
        switch ($tag) {
            case 'BRAND': return 'brand';
            case 'SERIES': return 'model';
            case 'VITOLA': return 'vitola';
            case 'SPECIAL': return 'special_edition';
            case 'YEAR': return 'year';
            case 'COUNT': return 'count';
            case 'DIM': return 'dimensions';
            case 'PACK': return 'packaging';
            default: return 'generic';
        }
    }
    
    // For untagged keywords, use pattern matching
    $keyword_lower = mb_strtolower($keyword);
    
    // Check for year pattern
    if (preg_match('/^(19|20)\d{2}$/', $keyword)) {
        return 'year';
    }
    
    // Check for dimension pattern
    if (preg_match('/\d+[xX×*\/]\d+/', $keyword) || preg_match('/^\d+\/\d+$/', $keyword)) {
        return 'dimensions';
    }
    
    // Check for count pattern
    if (preg_match('/^\d+(支|×|x|pcs|个|count|ct|-count)?$/i', $keyword)) {
        return 'count';
    }
    
    return 'generic';
}
	
	
	
	
	
	
	
	
	
    /**
     * Display a categorized keyword with styling
     * 
     * @param string $keyword The keyword to display
     * @param array $product Processed product data
     * @param array $data_file Data file with mappings
     * @return string HTML markup for the categorized keyword
     */
    private function display_categorized_keyword($keyword, $product = null, $data_file = null) {
    // Use KT_Cigar_Mappings to categorize the keyword if available
    if (class_exists('KT_Cigar_Mappings')) {
        $category = KT_Cigar_Mappings::categorize_keyword($keyword, $product);
    } else {
        $category = 'generic';
    }
    
    // Get color for category
    $color = isset($this->keyword_categories[$category]['color']) ? 
             $this->keyword_categories[$category]['color'] : 
             $this->keyword_categories['generic']['color'];
    
    $label = isset($this->keyword_categories[$category]['label']) ? 
             $this->keyword_categories[$category]['label'] : 
             $this->keyword_categories['generic']['label'];
    
    // Clean up the keyword for display
    $display_keyword = $keyword;
    if (preg_match('/^([A-Z_]+):(.+)$/i', $keyword, $matches)) {
        $display_keyword = trim($matches[2]); // Show just the value, not the tag
    }
    
    return '<span style="background: ' . $color . '; padding: 3px 8px; border-radius: 3px; display: inline-block; margin: 2px;" title="' . $label . '">' . esc_html($display_keyword) . '</span>';
}
    
    /**
     * Determine the categories for a keyword
     * 
     * @param string $keyword The keyword to categorize
     * @param array $product The processed product data
     * @param array $data_file The data file with mappings
     * @return array Array of applicable categories
     */
   
	private function determine_keyword_categories($keyword, $product, $data_file) {
        // First check for tagged keywords which have explicit categorization - this is the most reliable
        if (preg_match('/^([A-Z_]+):(.+)$/i', $keyword, $matches)) {
            $tag = strtoupper($matches[1]);
            $value = $matches[2];
            
            // Direct mapping of tags to categories - prioritize explicit tags
            switch ($tag) {
                case 'BRAND':
                    return ['brand'];
                case 'BRAND_VAR':
                    return ['brand'];
                case 'SERIES':
                    return ['model'];
                case 'VITOLA':
                    return ['vitola'];
                case 'SPECIAL':
                    return ['special_edition'];
                case 'YEAR':
                    return ['year'];
                case 'COUNT':
                    return ['count'];
                case 'DIM':
                    return ['dimensions'];
                case 'PACK':
                    return ['packaging'];
                case 'GENERIC':
                    return ['generic'];
                case 'NUM':
                    // For numbers, look at value to determine if it's count, ring, length, etc.
                    if ((int)$value >= 20 && (int)$value <= 70) {
                        return ['dimensions']; // Likely ring gauge
                    } else if ((int)$value >= 4 && (int)$value <= 9) {
                        return ['dimensions']; // Likely length
                    } else if ((int)$value >= 1900 && (int)$value <= date('Y')) {
                        return ['year']; // Likely year
                    } else if ((int)$value >= 5 && (int)$value <= 50) {
                        return ['count']; // Likely count
                    }
                    return ['generic'];
                case 'FULL':
                    return ['generic']; // The full text is just for reference
                default:
                    // If unknown tag, proceed with normal categorization
                    $keyword = $value; // Use the value part for further processing
                    break;
            }
        }
        
        // For keywords without tags or with unknown tags, perform normal categorization
        // Convert keyword to lowercase for case-insensitive comparison
        $keyword_lower = strtolower(trim($keyword));
        $product_brand = !empty($product["brand"]) ? strtolower(trim($product["brand"])) : '';
        
        // Array to store all matched categories
        $matched_categories = [];
        
        // Step 1: Check for exact structured data matches first
        if (strpos($keyword, 'BRAND:') === 0 || strpos($keyword, 'SPECIAL:') === 0) {
            // This is a directly tagged keyword, return the appropriate category
            $tag_parts = explode(':', $keyword, 2);
            $tag = strtoupper($tag_parts[0]);
            
            switch ($tag) {
                case 'BRAND': return ['brand'];
                case 'SPECIAL': return ['special_edition'];
                case 'VITOLA': return ['vitola'];
                case 'PACK': return ['packaging'];
                case 'COUNT': return ['count'];
                case 'YEAR': return ['year'];
                case 'DIM': return ['dimensions'];
                case 'GENERIC': return ['generic'];
                default: break;
            }
        }
        
        // Step 2: Check for clear dimension patterns (highest confidence)
        if ($this->is_clear_dimension($keyword_lower)) {
            return ['dimensions']; // Definitive dimension pattern
        }
        
        // Step 3: Check for clear count patterns (high confidence)
        if ($this->is_clear_count($keyword_lower)) {
            return ['count']; // Definitive count pattern
        }
        
        // Step 4: CRITICAL - Check if this keyword is another brand (not the product's brand)
        // If it is, skip further categorization to prevent cross-brand contamination
        if ($this->is_any_brand($keyword_lower, $data_file) && !$this->is_exact_brand_match($keyword_lower, $product_brand, $data_file)) {
            return ['generic']; // Force generic category for other brands to prevent contamination
        }
        
        // Step 5: Brand check with strict brand matching
        // Only categorize as brand if it matches the product's brand exactly
        if (!empty($product_brand) && $this->is_exact_brand_match($keyword_lower, $product_brand, $data_file)) {
            return ['brand']; // Early return - if it's a brand match, this is definitive
        }
        
        // Step 6: Series/Model check - only for the product's brand
        if (!empty($product_brand) && $this->is_series_for_brand($keyword_lower, $product_brand, $data_file)) {
            return ['model']; // Early return - if it's a series match, this is definitive
        }
        
        // Step 7: Vitola/Size check
        if ($this->is_vitola($keyword_lower, $data_file)) {
            $matched_categories[] = 'vitola';
        }
        
        // Step 8: Special Edition check
        if ($this->is_special_edition($keyword_lower, $data_file)) {
            $matched_categories[] = 'special_edition';
        }
        
        // Step 9: Year check - more precise year detection
        if ($this->is_year1($keyword_lower, $data_file) || 
            (is_numeric($keyword_lower) && (int)$keyword_lower >= 1900 && (int)$keyword_lower <= date('Y'))) {
            $matched_categories[] = 'year';
        }
        
        // Step 10: Dimension check for numeric values
        if (is_numeric($keyword_lower)) {
            $num = (int)$keyword_lower;
            if ($num >= 20 && $num <= 70) {
                // Likely a ring gauge
                $matched_categories[] = 'dimensions';
            } else if ($num >= 80 && $num <= 210) {
                // Likely a length
                $matched_categories[] = 'dimensions';
            } else if ($this->might_be_dimension($keyword_lower, $product)) {
                // Check product context for dimensions
                $matched_categories[] = 'dimensions';
            }
        }
        
        // Step 11: Count check for numeric values
        if (is_numeric($keyword_lower)) {
            $num = (int)$keyword_lower;
            if ($num >= 1 && $num <= 50 && $this->might_be_count($keyword_lower)) {
                $matched_categories[] = 'count';
            }
        }
        
        // Step 12: Check packaging last
        if ($this->is_packaging($keyword_lower, $data_file)) {
            $matched_categories[] = 'packaging';
        }
        
        // If we found multiple categories, prioritize them
        if (!empty($matched_categories)) {
            return $this->prioritize_categories($matched_categories, $keyword, $product);
        }
        
        // If no category was matched, return generic
        return ['generic'];
    }
    
    /**
     * Check if a keyword matches ANY brand in the data file
     */
    private function is_any_brand($keyword, $data_file) {
        if (empty($keyword) || empty($data_file)) {
            return false;
        }
        
        $keyword = strtolower(trim($keyword));
        
        // Check if it's a direct brand name
        foreach ($data_file['brands']['cuban'] as $brand => $variations) {
            if (strtolower($brand) === $keyword) {
                return true;
            }
            
            // Check variations
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        foreach ($data_file['brands']['non_cuban'] as $brand => $variations) {
            if (strtolower($brand) === $keyword) {
                return true;
            }
            
            // Check variations
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        // Check brand aliases
        if (!empty($data_file['brand_aliases'])) {
            foreach ($data_file['brand_aliases'] as $alias => $brand_name) {
                if (strtolower($alias) === $keyword) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check for exact brand match - much stricter than the regular version
     */
    private function is_exact_brand_match($keyword, $product_brand, $data_file) {
        if (empty($keyword) || empty($product_brand)) {
            return false;
        }
        
        // Only match if keyword is EXACTLY equal to product brand
        if ($keyword === $product_brand) {
            return true;
        }
        
        // Check brand aliases - exact match only
        if (isset($data_file['brand_aliases'][$keyword]) && 
            strtolower($data_file['brand_aliases'][$keyword]) === $product_brand) {
            return true;
        }
        
        // Check brand variations - exact match only
        if (!empty($data_file['brands']['cuban'])) {
            foreach ($data_file['brands']['cuban'] as $brand => $variations) {
                if (strtolower($brand) === $product_brand) {
                    foreach ($variations as $variation) {
                        if (strtolower($variation) === $keyword) {
                            return true;
                        }
                    }
                }
            }
        }
        
        if (!empty($data_file['brands']['non_cuban'])) {
            foreach ($data_file['brands']['non_cuban'] as $brand => $variations) {
                if (strtolower($brand) === $product_brand) {
                    foreach ($variations as $variation) {
                        if (strtolower($variation) === $keyword) {
                            return true;
                        }
                    }
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword contains a clear dimension pattern
     */
    private function is_clear_dimension($keyword) {
        // Handle formats like "5 1/8 x 50" with spaces and fractions
        if (preg_match('/(\d+(?:\s+\d+\/\d+)?)\s*[xX×]\s*(\d+)/', $keyword)) {
            return true;
        }
        
        // Look for bracketed dimension notation (e.g. [140×50])
        if (preg_match('/[\[【](\d+)[×xX](\d+)[\]】]/', $keyword)) {
            return true;
        }
        
        // Length and ring gauge separated by slash (e.g. 124/50)
        if (preg_match('/^(\d+)\/(\d+)$/', $keyword)) {
            return true;
        }
        
        // Handle "Ring: 50" or "Length: 124" formats
        if (preg_match('/^(ring|gauge|length)\s*:?\s*\d+$/i', $keyword)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Check if a keyword contains a clear count pattern
     */
    private function is_clear_count($keyword) {
        // Explicit count patterns
        if (preg_match('/^(\d+)-Count(?:\s+box)?$/i', $keyword) || 
            preg_match('/^Count:\s+(\d+)$/i', $keyword) ||
            preg_match('/^(\d+)支\/盒$/', $keyword) ||
            preg_match('/^(\d+)支装$/', $keyword) ||
            preg_match('/^(\d+)-Count$/', $keyword)) {
            return true;
        }
        
        // Box of X pattern
        if (preg_match('/^Box\s+of\s+(\d+)$/i', $keyword)) {
            return true;
        }
        
        // Count followed by box or ct
        if (preg_match('/^(\d+)-Count box$/', $keyword) ||
            preg_match('/^(\d+)ct$/', $keyword) ||
            preg_match('/^(\d+)-ct$/', $keyword)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Check if a keyword is a series/model for the product's brand
     */
    private function is_series_for_brand($keyword, $product_brand, $data_file) {
        if (empty($keyword) || empty($product_brand)) {
            return false;
        }
        
        // Check if the brand has series data
        if (!isset($data_file['series'][$product_brand])) {
            return false;
        }
        
        // Check against series for this brand
        foreach ($data_file['series'][$product_brand] as $series => $variations) {
            if (strtolower($series) === $keyword) {
                return true;
            }
            
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword is a vitola/size
     */
    private function is_vitola($keyword, $data_file) {
        if (empty($keyword) || empty($data_file['sizes'])) {
            return false;
        }
        
        // Check against size mappings
        foreach ($data_file['sizes'] as $vitola => $variations) {
            if (strtolower($vitola) === $keyword) {
                return true;
            }
            
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        // Check vitola mappings which are more comprehensive
        if (!empty($data_file['vitola_mappings'])) {
            foreach ($data_file['vitola_mappings'] as $vitola => $variations) {
                if (strtolower($vitola) === $keyword) {
                    return true;
                }
                
                foreach ($variations as $variation) {
                    if (strtolower($variation) === $keyword) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword is a special edition
     */
    private function is_special_edition($keyword, $data_file) {
        if (empty($keyword) || empty($data_file['special_editions'])) {
            return false;
        }
        
        // Check against special editions
        foreach ($data_file['special_editions'] as $edition => $variations) {
            if (strtolower($edition) === $keyword) {
                return true;
            }
            
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        // Check limited editions by year
        if (!empty($data_file['limited_editions_by_year'])) {
            foreach ($data_file['limited_editions_by_year'] as $year => $editions) {
                foreach ($editions as $edition) {
                    if (strtolower($edition) === $keyword || 
                        strtolower($edition . ' ' . $year) === $keyword ||
                        strtolower('edicion limitada ' . $year) === $keyword ||
                        strtolower('limited edition ' . $year) === $keyword) {
                        return true;
                    }
                }
            }
        }
        
        // Additional special edition keywords
        $special_edition_keywords = [
            'limited', 'limitada', 'edicion', 'edition', 'reserva', 'gran reserva',
            'coleccion', 'collection', 'seleccion', 'selection', 'especial', 'special',
            'anniversary', 'aniversario', 'release', 'exclusive', 'exclusivo'
        ];
        
        if (in_array($keyword, $special_edition_keywords)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Check if a keyword is a year
     */
    private function is_year1($keyword, $data_file) {
        // Check for year patterns
        if (preg_match('/^(\d{4})$/', $keyword)) {
            $year = (int)$keyword;
            if ($year >= 1900 && $year <= date('Y')) {
                return true;
            }
        }
        
        // Check for year with edition/anniversary
        if (preg_match('/^(\d{4})\s*(?:edition|anniversary|año|aniversario)$/i', $keyword) ||
            preg_match('/^(?:edition|anniversary|año|aniversario)\s*(\d{4})$/i', $keyword)) {
            return true;
        }
        
        // Check for zodiac years
        if (!empty($data_file['zodiac_years'])) {
            foreach ($data_file['zodiac_years'] as $zodiac => $variations) {
                // Check for "Year of the X" patterns
                if (strtolower('year of the ' . $zodiac) === $keyword || 
                    strtolower($zodiac . ' year') === $keyword) {
                    return true;
                }
                
                foreach ($variations as $variation) {
                    if (strtolower('year of the ' . $variation) === $keyword || 
                        strtolower($variation . ' year') === $keyword) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword might be dimension-related based on context
     */
    private function might_be_dimension($keyword, $product) {
        $keyword_lower = strtolower(trim($keyword));
        
        // Check if it's a single number that could be a ring gauge (20-70 range)
        if (is_numeric($keyword) && (int)$keyword >= 20 && (int)$keyword <= 70) {
            // Check if this matches product's actual ring gauge
            if (!empty($product['dimension_info']['ring_gauge']) && 
                (int)$keyword == (int)$product['dimension_info']['ring_gauge']) {
                return true;
            }
        }
        
        // Check if it's a single number that could be a length (typically 4-9 inches)
        if (is_numeric($keyword) && (int)$keyword >= 4 && (int)$keyword <= 9) {
            // Check if this matches product's actual length
            if (!empty($product['dimension_info']['length']) && 
                (int)$keyword == (int)$product['dimension_info']['length']) {
                return true;
            }
        }
        
        // Check for specific dimension terms
        $dimension_terms = ['ring', 'gauge', 'rg', 'length', 'mm', 'inches', 'inch', 
                          '环径', '口径', '长度', '长', 'cepo', 'calibre'];
        
        foreach ($dimension_terms as $term) {
            if (strpos($keyword_lower, $term) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword might represent a count based on context
     */
    private function might_be_count($keyword) {
        // Check for numbers in typical count ranges (1-50)
        if (is_numeric($keyword)) {
            $num = (int)$keyword;
            if ($num >= 1 && $num <= 50) {
                return true;
            }
        }
        
        // Check for specific count terms
        $count_terms = ['count', 'ct', 'box of', '支装', '数量', '数目', '包装数量'];
        
        foreach ($count_terms as $term) {
            if (strpos(strtolower($keyword), $term) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Check if a keyword is related to packaging
     */
    private function is_packaging($keyword, $data_file) {
        if (empty($keyword) || empty($data_file['packaging'])) {
            return false;
        }
        
        // Check against packaging types
        foreach ($data_file['packaging'] as $type => $variations) {
            if (strtolower($type) === $keyword) {
                return true;
            }
            
            foreach ($variations as $variation) {
                if (strtolower($variation) === $keyword) {
                    return true;
                }
            }
        }
        
        // Additional packaging keywords
        $packaging_keywords = [
            'box', 'pack', 'jar', 'tube', 'tubo', 'tubos', 'cabinet',
            'humidor', 'bundle', 'sampler', 'case', 'tin', 'container'
        ];
        
        if (in_array($keyword, $packaging_keywords)) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Prioritize categories when multiple matches are found
     */
    private function prioritize_categories($categories, $keyword, $product) {
        // Define priority order (highest to lowest)
        $priority_order = [
            'brand',
            'model',
            'vitola',
            'special_edition',
            'year',
            'dimensions',
            'count',
            'packaging',
            'generic'
        ];
        
        // Sort categories by priority
        usort($categories, function($a, $b) use ($priority_order) {
            $pos_a = array_search($a, $priority_order);
            $pos_b = array_search($b, $priority_order);
            
            // If not found, assign lowest priority
            if ($pos_a === false) $pos_a = count($priority_order);
            if ($pos_b === false) $pos_b = count($priority_order);
            
            return $pos_a - $pos_b;
        });
        
        return $categories;
    }
    
    /**
     * Process a product title to extract relevant information - Enhanced version
     * 
     * @param string $title Product title
     * @param string $dimensions Dimensions string (optional)
     * @param string $description Product description (optional)
     * @return array Processed product data
   
   */
  public function process_product_title_enhanced($title, $dimensions = "", $description = "") {
    // Always use KT_Cigar_Mappings if available - it has all the logic we need
    if (class_exists('KT_Cigar_Mappings')) {
        $this->log_debug("Using KT_Cigar_Mappings for processing: " . $title);
        return KT_Cigar_Mappings::process_supplier_product($title, $dimensions, $description);
    }
    
    // If KT_Cigar_Mappings is not available, return basic structure
    $this->log_debug("KT_Cigar_Mappings not available, using basic processing");
    
    return array(
        "title" => $title,
        "normalized_title" => strtolower(trim($title)),
        "brand" => null,
        "model" => null,
        "vitola" => null,
        "special_edition" => null,
        "year" => null,
        "count" => null,
        "dimension_info" => array(
            "ring_gauge" => null,
            "length" => null,
            "format" => null
        ),
        "packaging" => null,
        "keywords" => array("FULL:" . strtolower(trim($title))),
        "filtered_title" => strtolower(trim($title))
    );
}
   



/**
 * Get existing mapping for a supplier product
 * 
 * @param string $supplier_name Supplier name
 * @param string $product_id Product ID
 * @return object|null Existing mapping or null
 */
private function get_existing_mapping($supplier_name, $product_id) {
    global $wpdb;
    $mapping_table = $wpdb->prefix . $this->mapping_table;
    
    return $wpdb->get_row($wpdb->prepare(
        "SELECT kt_sku, match_confidence, matched_terms FROM $mapping_table 
        WHERE supplier_name = %s AND supplier_id = %s",
        $supplier_name, $product_id
    ));
}

/**
 * Handle existing mapping
 * 
 * @param object $existing_mapping Existing mapping data
 * @param array $result Result array to populate
 * @return array Updated result
 */
private function handle_existing_mapping($existing_mapping, $result) {
    global $wpdb;
    $master_table = $wpdb->prefix . $this->master_table;
    
    $mapped_product = $wpdb->get_row($wpdb->prepare(
        "SELECT sku, product_title FROM $master_table WHERE sku = %s",
        $existing_mapping->kt_sku
    ));
    
    if ($mapped_product) {
        $result["match_status"] = $existing_mapping->match_confidence . "_match";
        
        $confidence_scores = array(
            "exact" => 100,
            "close" => 85,
            "possible" => 65
        );
        
        $result["best_match"] = array(
            "sku" => $mapped_product->sku,
            "title" => $mapped_product->product_title,
            "score" => $confidence_scores[$existing_mapping->match_confidence] ?? 50,
            "db_keywords" => array()
        );
        
        // Get existing matched terms if available
        if (!empty($existing_mapping->matched_terms)) {
            $result["matched_terms"] = explode(',', $existing_mapping->matched_terms);
        }
    }
    
    return $result;
}

/**
 * Process product with KT_Cigar_Mappings
 * 
 * @param string $product_title Product title
 * @return array Processed product data
 */

	private function process_product_with_mappings($product_title) {
    // Ensure KT_Cigar_Mappings is loaded
    if (!$this->ensure_kt_mappings_loaded()) {
        $this->log_debug("KT_Cigar_Mappings not available, using fallback for: $product_title");
        return array(
            "title" => $product_title,
            "keywords" => array("FULL:" . strtolower($product_title)),
            "brand" => null,
            "model" => null
        );
    }
    
    try {
        
		// Extract dimensions from the product data if available
$dimensions = "";
if (isset($product["ring_gauge"]) && isset($product["length"])) {
    $dimensions = $product["ring_gauge"] . "/" . $product["length"];
}

$processed_product = KT_Cigar_Mappings::process_supplier_product(
    $product_title,
    $dimensions,
    isset($product["description"]) ? $product["description"] : ""
);
		
        $this->log_debug("KT_Cigar_Mappings extracted " . count($processed_product["keywords"] ?? []) . " keywords");
        
        // CRITICAL DEBUG: Log what brand was extracted
        $extracted_brand = $processed_product["brand"] ?? "NONE";
        $this->log_debug("BRAND EXTRACTION DEBUG: Title='$product_title' -> Extracted Brand='$extracted_brand'");
        
        return $processed_product;
    } catch (Exception $e) {
        $this->log_debug("ERROR in KT_Cigar_Mappings processing: " . $e->getMessage());
        return array(
            "title" => $product_title,
            "keywords" => array("FULL:" . strtolower($product_title)),
            "brand" => null,
            "model" => null
        );
    }
}

/**
 * Process database products for matching
 * 
 * @param array $db_products Array of database products
 * @return array Array of processed database products
 */
private function process_database_products($db_products) {
    $db_processed_products = array();
    
    foreach ($db_products as $db_product) {
        // CRITICAL: Check if this product already has keywords from the table
        if (isset($db_product->keywords) && is_array($db_product->keywords) && !empty($db_product->keywords)) {
            // Use the pre-processed data directly - NO REPROCESSING
            $db_processed = array(
                "sku" => $db_product->sku,
                "id" => $db_product->id,
                "title" => $db_product->product_title,
                "brand" => isset($db_product->brand) ? $db_product->brand : "",
                "keywords" => $db_product->keywords,  // Use table keywords directly
                "dimension_info" => array(
                    "ring_gauge" => isset($db_product->seat_row) ? $db_product->seat_row : "",
                    "length" => isset($db_product->seat_number) ? $db_product->seat_number : ""
                )
            );
            
            $this->log_debug("Using pre-processed keywords for DB product " . $db_product->sku . ": " . count($db_product->keywords) . " keywords");
        } else {
            // This shouldn't happen if table method is working, but fallback
            $this->log_debug("WARNING: No pre-processed keywords for " . $db_product->sku . ", using fallback");
            $db_processed = $this->process_single_database_product($db_product);
        }
        
        // ENSURE keywords always exist
        if (empty($db_processed["keywords"]) || !is_array($db_processed["keywords"])) {
            $db_processed["keywords"] = array("FULL:" . strtolower($db_product->product_title));
            $this->log_debug("EMERGENCY: Added fallback keywords for " . $db_product->sku);
        }
        
        $this->log_debug("FINAL DB Product " . $db_product->sku . " has " . count($db_processed["keywords"]) . " keywords: " . json_encode(array_slice($db_processed["keywords"], 0, 3)));
        $db_processed_products[] = $db_processed;
    }
    
    return $db_processed_products;
}

/**
 * ADD THIS METHOD: Check if keywords table has data
 */
public function check_keywords_table_status() {
    global $wpdb;
    $keywords_table = $wpdb->prefix . 'kt_cigar_processed_keywords';
    
    // Check if table exists
    if ($wpdb->get_var("SHOW TABLES LIKE '$keywords_table'") != $keywords_table) {
        return array(
            'exists' => false,
            'message' => 'Keywords table does not exist'
        );
    }
    
    // Check row count
    $row_count = $wpdb->get_var("SELECT COUNT(*) FROM $keywords_table");
    
    // Check sample keywords format
    $sample = $wpdb->get_row("SELECT sku, keywords FROM $keywords_table WHERE keywords IS NOT NULL LIMIT 1");
    
    $sample_keywords_valid = false;
    if ($sample && !empty($sample->keywords)) {
        $decoded = json_decode($sample->keywords, true);
        $sample_keywords_valid = is_array($decoded) && !empty($decoded);
    }
    
    return array(
        'exists' => true,
        'row_count' => $row_count,
        'sample_sku' => $sample ? $sample->sku : 'none',
        'sample_keywords_valid' => $sample_keywords_valid,
        'sample_keywords_preview' => $sample ? substr($sample->keywords, 0, 200) : 'none'
    );
}

/**
 * Process a single database product
 * 
 * @param object $db_product Database product object
 * @return array Processed product data
 */
private function process_single_database_product($db_product) {
    $dimensions = "";
    if (!empty($db_product->seat_row) || !empty($db_product->seat_number)) {
        $dimensions = (!empty($db_product->seat_row) ? $db_product->seat_row : "") . "/" . 
                      (!empty($db_product->seat_number) ? $db_product->seat_number : "");
    }
    
    if (class_exists('KT_Cigar_Mappings')) {
        $db_processed = KT_Cigar_Mappings::process_internal_product(
            $db_product->sku,
            $db_product->product_title,
            $dimensions
        );
    } else {
        $db_processed = $this->process_product_title_enhanced($db_product->product_title, $dimensions);
    }

    $db_processed["sku"] = $db_product->sku;
    $db_processed["id"] = $db_product->id;
    $db_processed["title"] = $db_product->product_title;
    
    if (empty($db_processed["keywords"])) {
        $db_processed["keywords"] = array("FULL:" . strtolower($db_product->product_title));
        $this->log_debug("WARNING: No keywords extracted for DB product " . $db_product->sku . ", using fallback");
    } else {
        $this->log_debug("SUCCESS: Processed DB Product " . $db_product->sku . " with " . count($db_processed["keywords"]) . " keywords");
    }
    
    return $db_processed;
}
/**
 * SIMPLIFIED: Process the best match - keywords fetched separately
 */
private function process_best_match($best_match, $result, $processed_product) {
    $this->log_debug("=== SIMPLIFIED PROCESS_BEST_MATCH ===");
    
    // Extract matched terms if available
    $matched_terms = array();
    if (isset($best_match["matched_terms"]) && is_array($best_match["matched_terms"])) {
        $matched_terms = $best_match["matched_terms"];
    } else if (!empty($processed_product["keywords"])) {
        $matched_terms = $processed_product["keywords"];
    }
    
    // Determine match status based on score
    $match_status = "no_match";
    if ($best_match["match_type"] === "Exact Match") {
        $match_status = "exact_match";
    } else if ($best_match["match_type"] === "Close Match") {
        $match_status = "close_match";
    } else if ($best_match["match_type"] === "Possible Match") {
        $match_status = "possible_match";
    }
    
    $result["match_status"] = $match_status;
    
    // SIMPLIFIED: Just get the basic match info - keywords will be fetched separately
    $result["best_match"] = array(
        "sku" => $best_match["product"]["sku"],
        "title" => $best_match["product"]["title"], 
        "score" => round($best_match["score"])
        // NO db_keywords here - we'll fetch them separately!
    );
    
    $result["matched_terms"] = $matched_terms;
    
    $this->log_debug("SIMPLIFIED: Match created for SKU: " . $best_match["product"]["sku"]);
    return $result;
}

/**
 * Get potential database matches based on product info - TABLE VERSION
 * 
 * @param array $processed_product Processed product data
 * @return array Array of potential database matches
 */

	/**
 * FIXED: Get potential database matches based on product info - TABLE VERSION
 * This ensures pre-processed keywords from the database table are properly used
 */
/**




/**
 * Enhanced brand extraction with better Chinese mapping
 */
private function extract_brand_from_title($title) {
    $this->log_debug("Extracting brand from: " . $title);
    
    // Clean the title
    $title = $this->clean_title($title);
    $title_lower = mb_strtolower($title, 'UTF-8');
    
    // Load brand mappings
    $brand_data = $this->load_brand_mappings();
    
    $best_match = null;
    $best_score = 0;
    $best_length = 0;
    
    // Check all brand categories
    foreach (['cuban', 'non_cuban'] as $category) {
        if (!isset($brand_data['brands'][$category])) continue;
        
        foreach ($brand_data['brands'][$category] as $brand_key => $aliases) {
            foreach ($aliases as $alias) {
                $alias_lower = mb_strtolower($alias, 'UTF-8');
                
                // Exact match (highest priority)
                if ($alias_lower === $title_lower) {
                    $this->log_debug("Exact brand match found: {$brand_key} via alias: {$alias}");
                    return $brand_key;
                }
                
                // Starts with match
                if (mb_strpos($title_lower, $alias_lower) === 0) {
                    $match_length = mb_strlen($alias_lower);
                    if ($match_length > $best_length) {
                        $best_match = $brand_key;
                        $best_score = 1.0;
                        $best_length = $match_length;
                        $this->log_debug("Brand prefix match: {$brand_key} via alias: {$alias} (length: {$match_length})");
                    }
                }
                
                // Contains match (lower priority)
                elseif (mb_strpos($title_lower, $alias_lower) !== false) {
                    $match_length = mb_strlen($alias_lower);
                    if ($match_length > $best_length && $best_score < 0.8) {
                        $best_match = $brand_key;
                        $best_score = 0.8;
                        $best_length = $match_length;
                        $this->log_debug("Brand contains match: {$brand_key} via alias: {$alias} (length: {$match_length})");
                    }
                }
            }
        }
    }
    
    if ($best_match) {
        $this->log_debug("Best brand match: {$best_match} (score: {$best_score}, length: {$best_length})");
        return $best_match;
    }
    
    $this->log_debug("No brand match found for: " . $title);
    return null;
}

/**
 * Optimized main matching method with early brand validation
 */
public function process_supplier_product($product) {
    $this->log_debug("=== Processing Product ID: {$product['id']} ===");
    $this->log_debug("Product Title: {$product['title']}");
    
    // STEP 1: Extract brand FIRST (critical for performance)
    $extracted_brand = $this->extract_brand_from_title($product['title']);
    
    if (empty($extracted_brand)) {
        $this->log_debug("No brand extracted - marking as no match");
        return [
            'status' => 'no_match',
            'confidence' => 0,
            'best_match' => null,
            'all_matches' => [],
            'extracted_info' => [],
            'reason' => 'No brand could be identified from title'
        ];
    }
    
    $this->log_debug("Extracted brand: {$extracted_brand}");
    
    // STEP 2: Get potential matches (now brand-filtered)
    $potential_matches = $this->get_potential_database_matches($product, $extracted_brand);
    
    if (empty($potential_matches)) {
        $this->log_debug("No potential matches found for brand: {$extracted_brand}");
        return [
            'status' => 'no_match',
            'confidence' => 0,
            'best_match' => null,
            'all_matches' => [],
            'extracted_info' => ['brand' => $extracted_brand],
            'reason' => 'No products found for extracted brand'
        ];
    }
    
    $this->log_debug("Found " . count($potential_matches) . " potential matches for brand: {$extracted_brand}");
    
    // STEP 3: Extract additional info for better matching
    $extracted_info = $this->extract_product_info($product['title']);
    $extracted_info['brand'] = $extracted_brand;
    
    // STEP 4: Score each potential match
    $scored_matches = [];
    foreach ($potential_matches as $db_product) {
        $score = $this->calculate_match_score($product, $db_product, $extracted_info);
        if ($score > 0.3) { // Only keep reasonable matches
            $scored_matches[] = [
                'product' => $db_product,
                'score' => $score,
                'extracted_info' => $extracted_info
            ];
        }
    }
    
    if (empty($scored_matches)) {
        $this->log_debug("No scored matches above threshold");
        return [
            'status' => 'no_match',
            'confidence' => 0,
            'best_match' => null,
            'all_matches' => [],
            'extracted_info' => $extracted_info,
            'reason' => 'No matches above confidence threshold'
        ];
    }
    
    // STEP 5: Sort and return best matches
    usort($scored_matches, function($a, $b) {
        return $b['score'] <=> $a['score'];
    });
    
    $best_match = $scored_matches[0];
    $confidence = $best_match['score'];
    
    // Determine status based on confidence
    $status = 'no_match';
    if ($confidence >= 0.95) {
        $status = 'exact_match';
    } elseif ($confidence >= 0.85) {
        $status = 'close_match';
    } elseif ($confidence >= 0.65) {
        $status = 'possible_match';
    }
    
    $this->log_debug("Best match: {$best_match['product']->sku} (score: {$confidence})");
    
    return [
        'status' => $status,
        'confidence' => $confidence,
        'best_match' => $best_match['product'],
        'all_matches' => array_slice($scored_matches, 0, 5), // Top 5 matches
        'extracted_info' => $extracted_info,
        'reason' => "Matched with {$confidence} confidence"
    ];
}

/**
 * Evaluate if a product matches the criteria
 * 
 * @param array $product Product data
 * @param string $brand Brand filter
 * @param string $vitola Vitola filter
 * @param string $year Year filter
 * @param string $ring_gauge Ring gauge filter
 * @param string $length Length filter
 * @return bool Whether product matches
 */
private function evaluate_product_match($product, $brand, $vitola, $year, $ring_gauge, $length) {
    $match = false;
    
    // Brand matching (primary filter)
    if (!empty($brand)) {
        // Only filter if we have a valid brand
        if (stripos($product['brand'], $brand) !== false || 
            stripos($product['title'], $brand) !== false) {
            $match = true;
        }
        
        // Check brand aliases and variations
        if (!$match) {
            $data_file = $this->load_data_file();
            if (!empty($data_file['brand_aliases'])) {
                foreach ($data_file['brand_aliases'] as $alias => $original) {
                    if ((strtolower($alias) === strtolower($brand) && stripos($product['brand'], $original) !== false) ||
                        (strtolower($original) === strtolower($brand) && stripos($product['brand'], $alias) !== false)) {
                        $match = true;
                        break;
                    }
                }
            }
        }
    } else {
        // CRITICAL: When no brand extracted, include ALL products for broader matching
        $match = true;
        $this->log_debug("No brand extracted - including all products for matching");
    }
    
    // Additional filters (if brand matches or no brand specified)
    if ($match) {
        // Vitola filter
        if (!empty($vitola) && stripos($product['title'], $vitola) === false) {
            return false;
        }
        
        // Year filter
        if (!empty($year) && stripos($product['title'], $year) === false) {
            return false;
        }
        
        // Dimension filters
        if (!empty($ring_gauge) && !empty($length)) {
            $ring_min = $ring_gauge - 2;
            $ring_max = $ring_gauge + 2;
            $length_min = $length - 10;
            $length_max = $length + 10;
            
            $product_ring = intval($product['seat_row']);
            $product_length = intval($product['seat_number']);
            
            if (($product_ring < $ring_min || $product_ring > $ring_max) &&
                ($product_length < $length_min || $product_length > $length_max)) {
                return false;
            }
        }
    }
    
    return $match;
}

/**
 * Find best matches between a supplier product and database products
 * 
 * @param array $supplier_product Processed supplier product data
 * @param array $db_products Array of processed database products
 * @param int $limit Maximum number of matches to return
 * @param bool $include_debug Whether to include debug information in results
 * @return array Best matches with their scores
 */
/**
 * FIXED: Find best matches between a supplier product and database products
 * This ensures keywords are properly preserved throughout the matching process
 */
private function find_best_matches($supplier_product, $db_products, $limit = 3, $include_debug = false) {
    if (empty($supplier_product) || empty($db_products)) {
        return array();
    }
    
    // ADD DEBUG LOGGING
    $this->log_debug("=== FIND_BEST_MATCHES DEBUG ===");
    $this->log_debug("Supplier keywords: " . json_encode($supplier_product["keywords"] ?? []));
    $this->log_debug("Processing " . count($db_products) . " database products");
    
    // Check first 3 DB products for keywords
    for ($i = 0; $i < min(3, count($db_products)); $i++) {
        $db_data = $this->extract_database_data($db_products[$i]);
        $this->log_debug("DB Product $i ({$db_data['sku']}): " . count($db_data['keywords']) . " keywords");
    }
    
    $matches = array();
    
    // Get the basic info from the supplier product
    $supplier_data = $this->extract_supplier_data($supplier_product);
    
    // Calculate scores for each database product
    foreach ($db_products as $db_product) {
        $db_data = $this->extract_database_data($db_product);
        
        $this->log_debug("Matching against {$db_data['sku']} with " . count($db_data['keywords']) . " keywords");
        
        // Calculate score components
        $scores = $this->calculate_match_scores($supplier_data, $db_data);
        
        // Calculate final score with appropriate weights
        $final_score = $this->calculate_final_score($scores);
        
        // Determine match type based on score and brand matching
        $match_type = $this->determine_match_type($final_score, $scores['brand']);
        
        // CRITICAL FIX: Create standardized match result with GUARANTEED keyword preservation
        $match_data = array(
            "product" => array(
                "sku" => $db_data['sku'],
                "title" => $db_data['title'],
                "keywords" => $db_data['keywords'],  // ENSURE keywords are here
                "product_title" => $db_data['title']
            ),
            "score" => $final_score,
            "match_type" => $match_type,
            "keywords" => $db_data['keywords'],     // ALSO at top level
            "db_keywords" => $db_data['keywords']   // EXPLICIT db_keywords field
        );
        
        // VERIFICATION: Double-check keywords are preserved
        if (empty($match_data["db_keywords"]) || !is_array($match_data["db_keywords"])) {
            $this->log_debug("CRITICAL: DB keywords missing for " . $db_data['sku'] . " after match creation!");
            // Emergency restoration
            $match_data["db_keywords"] = array("FULL:" . strtolower($db_data['title']));
            $match_data["keywords"] = $match_data["db_keywords"];
            $match_data["product"]["keywords"] = $match_data["db_keywords"];
        }
        
        $keyword_count = count($match_data["db_keywords"]);
        $this->log_debug("MATCH CREATED: {$db_data['sku']} with $keyword_count keywords preserved");
        
        // If debug is enabled, add detailed score breakdown
        if ($include_debug) {
            $match_data["scores"] = $scores;
            $match_data["matched_terms"] = $this->get_matched_terms($supplier_data, $db_data);
        }
        
        $matches[] = $match_data;
    }
    
    // Sort matches by score (descending)
    usort($matches, function($a, $b) {
        return $b["score"] <=> $a["score"];
    });
    
    // FINAL VERIFICATION before returning
    $top_matches = array_slice($matches, 0, $limit);
    foreach ($top_matches as $i => $match) {
        $keyword_count = count($match["db_keywords"] ?? []);
        $this->log_debug("FINAL MATCH $i: {$match['product']['sku']} has $keyword_count keywords");
        
        if ($keyword_count === 0) {
            $this->log_debug("EMERGENCY FIX: Adding fallback keywords to match $i");
            $top_matches[$i]["db_keywords"] = array("EMERGENCY:" . strtolower($match["product"]["title"]));
        }
    }
    
    $this->log_debug("=== END FIND_BEST_MATCHES DEBUG ===");
    
    return $top_matches;
}

/**
 * Extract supplier data for matching
 * 
 * @param array $supplier_product Supplier product data
 * @return array Extracted data
 */
private function extract_supplier_data($supplier_product) {
    return array(
        'brand' => strtolower(trim($supplier_product["brand"] ?? "")),
        'model' => strtolower(trim($supplier_product["model"] ?? "")),
        'vitola' => strtolower(trim($supplier_product["vitola"] ?? "")),
        'special' => strtolower(trim($supplier_product["special_edition"] ?? "")),
        'year' => $supplier_product["year"] ?? "",
        'ring' => $supplier_product["dimension_info"]["ring_gauge"] ?? "",
        'length' => $supplier_product["dimension_info"]["length"] ?? "",
        'keywords' => is_array($supplier_product["keywords"]) ? $supplier_product["keywords"] : array(),
        'normalized_title' => strtolower($supplier_product["normalized_title"] ?? "")
    );
}

/**
 * Extract database data for matching
 * 
 * @param mixed $db_product Database product (object or array)
 * @return array Extracted data
/**
 * FIXED: Extract database data for matching with guaranteed keyword handling
 */
/**
 * SIMPLIFIED: Extract database data - keywords fetched separately when needed
 */
private function extract_database_data($db_product) {
    if (is_object($db_product)) {
        return array(
            'brand' => strtolower(trim($db_product->brand ?? "")),
            'sku' => $db_product->sku,
            'title' => $db_product->product_title,
            'keywords' => array("PLACEHOLDER"), // We'll fetch these separately when needed
            'ring' => $db_product->seat_row ?? "",
            'length' => $db_product->seat_number ?? "",
            'normalized_title' => strtolower($db_product->product_title ?? "")
        );
    } else {
        return array(
            'brand' => strtolower(trim($db_product["brand"] ?? "")),
            'sku' => $db_product["sku"],
            'title' => $db_product["title"],
            'keywords' => array("PLACEHOLDER"), // We'll fetch these separately when needed
            'ring' => $db_product["dimension_info"]["ring_gauge"] ?? "",
            'length' => $db_product["dimension_info"]["length"] ?? "",
            'normalized_title' => strtolower($db_product["title"] ?? "")
        );
    }
}
/**
 * Calculate match scores between supplier and database data
 * 
 * @param array $supplier_data Supplier data
 * @param array $db_data Database data
 * @return array Score components
 */
/**
 * FIXED: Calculate match scores with STRICT brand requirement
 */
private function calculate_match_scores($supplier_data, $db_data) {
    $scores = array();
    
    // Log what we're comparing for debugging
    $this->log_debug("=== DETAILED MATCH SCORING ===");
    $this->log_debug("Supplier brand: " . ($supplier_data['brand'] ?? 'NONE'));
    $this->log_debug("DB brand: " . ($db_data['brand'] ?? 'NONE'));
    $this->log_debug("Supplier model: " . ($supplier_data['model'] ?? 'NONE'));
    $this->log_debug("DB model: " . ($db_data['model'] ?? 'NONE'));
    
    // CRITICAL: Brand matching is MANDATORY
    $brand_matched = false;
    
    if (!empty($supplier_data['brand']) && !empty($db_data['brand'])) {
        // Use KT_Cigar_Mappings to check if brands are the same
        if (class_exists('KT_Cigar_Mappings')) {
            $brand_matched = KT_Cigar_Mappings::is_same_brand($supplier_data['brand'], $db_data['brand']);
        } else {
            $brand_matched = (mb_strtolower($supplier_data['brand']) === mb_strtolower($db_data['brand']));
        }
        
        if ($brand_matched) {
            $scores['brand'] = 5.0;
            $this->log_debug("Brand match: {$supplier_data['brand']} == {$db_data['brand']}");
        } else {
            $this->log_debug("Brand mismatch: {$supplier_data['brand']} != {$db_data['brand']}");
            // Return zero scores for everything if brands don't match
            return array(
                'brand' => 0.0,
                'model' => 0.0,
                'vitola' => 0.0,
                'special' => 0.0,
                'year' => 0.0,
                'dimension' => 0.0,
                'keyword' => 0.0
            );
        }
    } else if (empty($supplier_data['brand']) && empty($db_data['brand'])) {
        // Both missing brand - allow but with lower score
        $scores['brand'] = 1.0;
        $brand_matched = true;
    } else {
        // One has brand, other doesn't - no match
        $this->log_debug("Brand mismatch: one has brand, other doesn't");
        return array(
            'brand' => 0.0,
            'model' => 0.0,
            'vitola' => 0.0,
            'special' => 0.0,
            'year' => 0.0,
            'dimension' => 0.0,
            'keyword' => 0.0
        );
    }
    
    // Only calculate other scores if brands match
    if ($brand_matched) {
        // Model/Series matching - ENHANCED for number normalization
        if (!empty($supplier_data['model']) && !empty($db_data['model'])) {
            // First try exact match
            if (mb_strtolower($supplier_data['model']) === mb_strtolower($db_data['model'])) {
                $scores['model'] = 4.0;
                $this->log_debug("Model exact match: {$supplier_data['model']}");
            } else {
                // Try normalized comparison for numbered series
                $supplier_model_norm = $this->normalizeSeriesName($supplier_data['model']);
                $db_model_norm = $this->normalizeSeriesName($db_data['model']);
                
                if ($supplier_model_norm === $db_model_norm) {
                    $scores['model'] = 4.0; // Full score for normalized match
                    $this->log_debug("Model normalized match: {$supplier_data['model']} -> {$supplier_model_norm} == {$db_data['model']} -> {$db_model_norm}");
                } else if (mb_stripos($db_data['model'], $supplier_data['model']) !== false || 
                          mb_stripos($supplier_data['model'], $db_data['model']) !== false) {
                    $scores['model'] = 2.5;
                    $this->log_debug("Model partial match");
                } else {
                    $scores['model'] = 0.0; // Different models
                    $this->log_debug("Model mismatch: {$supplier_data['model']} != {$db_data['model']}");
                }
            }
        } else if (!empty($supplier_data['model']) || !empty($db_data['model'])) {
            // One has model, other doesn't - penalize
            $scores['model'] = 0.0;
            $this->log_debug("Model mismatch: one has model, other doesn't");
        } else {
            // Both missing model
            $scores['model'] = 1.0;
        }
        
        // Vitola matching
        if (!empty($supplier_data['vitola']) && !empty($db_data['vitola'])) {
            if (mb_strtolower($supplier_data['vitola']) === mb_strtolower($db_data['vitola'])) {
                $scores['vitola'] = 3.0;
            } else if (mb_stripos($db_data['vitola'], $supplier_data['vitola']) !== false || 
                      mb_stripos($supplier_data['vitola'], $db_data['vitola']) !== false) {
                $scores['vitola'] = 2.0;
            } else {
                // Check if vitolas are related using data file
                if (class_exists('KT_Cigar_Mappings')) {
                    $data_file = KT_Cigar_Mappings::get_data_file();
                    if (!empty($data_file["vitola_mappings"])) {
                        $related = false;
                        foreach ($data_file["vitola_mappings"] as $vitola => $variations) {
                            if ((mb_strtolower($vitola) === mb_strtolower($supplier_data['vitola']) || 
                                 in_array(mb_strtolower($supplier_data['vitola']), array_map('mb_strtolower', $variations))) &&
                                (mb_strtolower($vitola) === mb_strtolower($db_data['vitola']) || 
                                 in_array(mb_strtolower($db_data['vitola']), array_map('mb_strtolower', $variations)))) {
                                $related = true;
                                break;
                            }
                        }
                        $scores['vitola'] = $related ? 2.5 : 0.5;
                    } else {
                        $scores['vitola'] = 0.5;
                    }
                } else {
                    $scores['vitola'] = 0.5;
                }
            }
        } else {
            $scores['vitola'] = 0.0;
        }
        
        // Special edition matching
        if (!empty($supplier_data['special_edition']) && !empty($db_data['special_edition'])) {
            if (mb_strtolower($supplier_data['special_edition']) === mb_strtolower($db_data['special_edition'])) {
                $scores['special'] = 3.0;
            } else if (mb_stripos($db_data['special_edition'], $supplier_data['special_edition']) !== false || 
                      mb_stripos($supplier_data['special_edition'], $db_data['special_edition']) !== false) {
                $scores['special'] = 2.0;
            } else {
                $scores['special'] = 0.5;
            }
        } else {
            $scores['special'] = 0.0;
        }
        
        // Year matching
        if (!empty($supplier_data['year']) && !empty($db_data['year'])) {
            if ($supplier_data['year'] === $db_data['year']) {
                $scores['year'] = 3.0;
            } else {
                $year_diff = abs((int)$supplier_data['year'] - (int)$db_data['year']);
                if ($year_diff <= 1) {
                    $scores['year'] = 2.0;
                } else if ($year_diff <= 3) {
                    $scores['year'] = 1.0;
                } else {
                    $scores['year'] = 0.0;
                }
            }
        } else {
            $scores['year'] = 0.0;
        }
        
        // Dimension matching
        $scores['dimension'] = $this->calculate_dimension_score(
            isset($supplier_data['dimension_info']['ring_gauge']) ? $supplier_data['dimension_info']['ring_gauge'] : null,
            isset($supplier_data['dimension_info']['length']) ? $supplier_data['dimension_info']['length'] : null,
            isset($db_data['dimension_info']['ring_gauge']) ? $db_data['dimension_info']['ring_gauge'] : null,
            isset($db_data['dimension_info']['length']) ? $db_data['dimension_info']['length'] : null
        );
        
        // Keyword matching - reduced weight
        $scores['keyword'] = $this->calculate_keyword_score(
            $supplier_data['keywords'] ?? array(),
            $db_data['keywords'] ?? array()
        ) * 0.5; // Reduce keyword score weight
    }
    
    $this->log_debug("Final scores: " . json_encode($scores));
    $this->log_debug("=== END MATCH SCORING ===");
    
    return $scores;
}

// Add this helper method to normalize series names
private function normalizeSeriesName($series) {
    if (empty($series)) return '';
    
    $normalized = mb_strtolower($series);
    
    // Remove common suffixes
    $normalized = str_replace(['号', '/', ' ', '-', '_'], '', $normalized);
    
    // Map Chinese numbers to Arabic
    $chinese_map = [
        '一' => '1', '二' => '2', '三' => '3', '四' => '4', '五' => '5',
        '六' => '6', '七' => '7', '八' => '8', '九' => '9', '十' => '10'
    ];
    
    foreach ($chinese_map as $chinese => $arabic) {
        $normalized = str_replace($chinese, $arabic, $normalized);
    }
    
    // Map Roman numerals to Arabic (do longer ones first)
    $roman_map = [
        'x' => '10', 'ix' => '9', 'viii' => '8', 'vii' => '7', 'vi' => '6',
        'v' => '5', 'iv' => '4', 'iii' => '3', 'ii' => '2', 'i' => '1'
    ];
    
    foreach ($roman_map as $roman => $arabic) {
        $normalized = preg_replace('/\b' . $roman . '\b/', $arabic, $normalized);
    }
    
    // Specific series normalizations
    $series_map = [
        'siglo1' => 'siglo_1',
        'siglo2' => 'siglo_2',
        'siglo3' => 'siglo_3',
        'siglo4' => 'siglo_4',
        'siglo5' => 'siglo_5',
        'siglo6' => 'siglo_6',
        '世纪1' => 'siglo_1',
        '世纪2' => 'siglo_2',
        '世纪3' => 'siglo_3',
        '世纪4' => 'siglo_4',
        '世纪5' => 'siglo_5',
        '世纪6' => 'siglo_6',
        'no.1' => 'no_1',
        'no.2' => 'no_2',
        'no.3' => 'no_3',
        'no.4' => 'no_4',
        'no.5' => 'no_5'
    ];
    
    foreach ($series_map as $variant => $standard) {
        if (strpos($normalized, $variant) !== false) {
            return $standard;
        }
    }
    
    return $normalized;
}
/**
 * Calculate brand matching score
 * 
 * @param string $supplier_brand Supplier brand
 * @param string $db_brand Database brand
 * @param string $supplier_title Supplier title
 * @param string $db_title Database title
 * @return float Brand score
 */
private function calculate_brand_score($supplier_brand, $db_brand, $supplier_title, $db_title) {
    if (!empty($supplier_brand) && !empty($db_brand)) {
        if ($supplier_brand === $db_brand) {
            return 5.0; // Perfect brand match
        }
        
        // Check for brand aliases
        $data_file = $this->load_data_file();
        if (!empty($data_file["brand_aliases"])) {
            foreach ($data_file["brand_aliases"] as $alias => $brand_name) {
                if ((strtolower($alias) === $supplier_brand && strtolower($brand_name) === $db_brand) ||
                    (strtolower($alias) === $db_brand && strtolower($brand_name) === $supplier_brand)) {
                    return 4.0; // Brand alias match
                }
            }
        }
        
        if (strpos($db_brand, $supplier_brand) !== false || 
            strpos($supplier_brand, $db_brand) !== false) {
            return 3.0; // Partial brand match
        }
        
        return 0.0; // Different brands
    }
    
    // Handle missing brand cases
    if (empty($supplier_brand) && !empty($db_brand)) {
        return strpos($supplier_title, $db_brand) !== false ? 3.0 : 0.5;
    } else if (!empty($supplier_brand) && empty($db_brand)) {
        return strpos($db_title, $supplier_brand) !== false ? 3.0 : 0.5;
    }
    
    return 0.5; // Both missing brand
}

/**
 * Calculate model matching score
 * 
 * @param string $supplier_model Supplier model
 * @param string $db_model Database model  
 * @param string $supplier_title Supplier title
 * @param string $db_title Database title
 * @return float Model score
 */
private function calculate_model_score($supplier_model, $db_model, $supplier_title, $db_title) {
    if (!empty($supplier_model) && !empty($db_model)) {
        if ($supplier_model === $db_model) {
            return 4.0; // Perfect model match
        } else if (strpos($db_model, $supplier_model) !== false || 
                  strpos($supplier_model, $db_model) !== false) {
            return 2.5; // Partial model match
        } else {
            return 0.5; // Different models
        }
    }
    
    // Handle missing model cases
    if (empty($supplier_model) && !empty($db_model)) {
        return strpos($supplier_title, $db_model) !== false ? 2.0 : 0.0;
    } else if (!empty($supplier_model) && empty($db_model)) {
        return strpos($db_title, $supplier_model) !== false ? 2.0 : 0.0;
    }
    
    return 0.0; // Both missing model
}

/**
 * Calculate vitola matching score
 * 
 * @param string $supplier_vitola Supplier vitola
 * @param string $db_vitola Database vitola
 * @param string $supplier_title Supplier title
 * @param string $db_title Database title
 * @return float Vitola score
 */
private function calculate_vitola_score($supplier_vitola, $db_vitola, $supplier_title, $db_title) {
    if (!empty($supplier_vitola) && !empty($db_vitola)) {
        if ($supplier_vitola === $db_vitola) {
            return 3.0; // Perfect vitola match
        } else if (strpos($db_vitola, $supplier_vitola) !== false || 
                  strpos($supplier_vitola, $db_vitola) !== false) {
            return 2.0; // Partial vitola match
        } else {
            // Check if vitolas are related using data file
            $data_file = $this->load_data_file();
            if (!empty($data_file["vitola_mappings"])) {
                foreach ($data_file["vitola_mappings"] as $vitola => $variations) {
                    if ((strtolower($vitola) === $supplier_vitola || in_array($supplier_vitola, array_map('strtolower', $variations))) &&
                        (strtolower($vitola) === $db_vitola || in_array($db_vitola, array_map('strtolower', $variations)))) {
                        return 2.5; // Related vitolas
                    }
                }
            }
            return 0.5; // Different vitolas
        }
    }
    
    return 0.0; // Missing vitola data
}

/**
 * Calculate special edition matching score
 * 
 * @param string $supplier_special Supplier special edition
 * @param string $db_special Database special edition
 * @return float Special edition score
 */
private function calculate_special_score($supplier_special, $db_special) {
    if (!empty($supplier_special) && !empty($db_special)) {
        if ($supplier_special === $db_special) {
            return 3.0; // Perfect special edition match
        } else if (strpos($db_special, $supplier_special) !== false || 
                  strpos($supplier_special, $db_special) !== false) {
            return 2.0; // Partial special edition match
        } else if ((strpos($supplier_special, 'limited') !== false && 
                   strpos($db_special, 'limited') !== false) ||
                  (strpos($supplier_special, 'regional') !== false && 
                   strpos($db_special, 'regional') !== false)) {
            return 1.5; // Both have limited or regional edition
        } else {
            return 0.5; // Different special editions
        }
    }
    
    return 0.0; // Missing special edition data
}

/**
 * Calculate year matching score
 * 
 * @param string $supplier_year Supplier year
 * @param string $db_year Database year
 * @return float Year score
 */
private function calculate_year_score($supplier_year, $db_year) {
    if (!empty($supplier_year) && !empty($db_year)) {
        if ($supplier_year === $db_year) {
            return 3.0; // Perfect year match
        } else {
            // Check how close the years are
            $year_diff = abs((int)$supplier_year - (int)$db_year);
            if ($year_diff <= 1) {
                return 2.0; // Off by 1 year
            } else if ($year_diff <= 3) {
                return 1.0; // Off by 2-3 years
            } else {
                return 0.0; // Significant year difference
            }
        }
    }
    
    return 0.0; // Missing year data
}

/**
 * Calculate dimension matching score
 * 
 * @param string $supplier_ring Supplier ring gauge
 * @param string $supplier_length Supplier length
 * @param string $db_ring Database ring gauge
 * @param string $db_length Database length
 * @return float Dimension score
 */
private function calculate_dimension_score($supplier_ring, $supplier_length, $db_ring, $db_length) {
    if ((!empty($supplier_ring) || !empty($supplier_length)) && 
        (!empty($db_ring) || !empty($db_length))) {
        
        $ring_match = false;
        $length_match = false;
        $dimension_score = 0.0;
        
        // Check ring gauge match
        if (!empty($supplier_ring) && !empty($db_ring)) {
            $ring_diff = abs((float)$supplier_ring - (float)$db_ring);
            $max_diff = max(1, (float)$supplier_ring * 0.05); // 5% tolerance or 1 unit
            
            if ($ring_diff <= $max_diff) {
                $ring_match = true;
            } else {
                // Calculate proximity score
                $ring_pct = min(1.0, max(0.0, 1.0 - ($ring_diff / (float)$supplier_ring)));
                $dimension_score += $ring_pct * 1.5;
            }
        }
        
        // Check length match
        if (!empty($supplier_length) && !empty($db_length)) {
            $length_diff = abs((float)$supplier_length - (float)$db_length);
            $max_diff = max(5, (float)$supplier_length * 0.05); // 5% tolerance or 5 units
            
            if ($length_diff <= $max_diff) {
                $length_match = true;
            } else {
                // Calculate proximity score
                $length_pct = min(1.0, max(0.0, 1.0 - ($length_diff / (float)$supplier_length)));
                $dimension_score += $length_pct * 1.5;
            }
        }
        
        // Score based on matches
        if ($ring_match && $length_match) {
            return 3.0; // Both dimensions match
        } else if ($ring_match || $length_match) {
            return 1.5; // One dimension matches
        } else {
            return $dimension_score; // Proximity-based score
        }
    }
    
    return 0.0; // Missing dimension data
}

/**
 * Calculate keyword matching score
 * 
 * @param array $supplier_keywords Supplier keywords
 * @param array $db_keywords Database keywords
 * @return float Keyword score
 */
private function calculate_keyword_score($supplier_keywords, $db_keywords) {
    $keyword_score = 0.0;
    $category_matches = array(
        'brand' => 0, 'model' => 0, 'vitola' => 0, 'special_edition' => 0,
        'year' => 0, 'dimensions' => 0, 'count' => 0, 'packaging' => 0, 'generic' => 0
    );
    
    foreach ($supplier_keywords as $supplier_keyword) {
        // Skip the FULL: keyword which is just for reference
        if (strpos($supplier_keyword, 'FULL:') === 0) {
            continue;
        }
        
        foreach ($db_keywords as $db_keyword) {
            // Skip the FULL: keyword which is just for reference
            if (strpos($db_keyword, 'FULL:') === 0) {
                continue;
            }
            
            $match_result = $this->match_keywords($supplier_keyword, $db_keyword);
            if ($match_result['score'] > 0) {
                $keyword_score += $match_result['score'];
                $category_matches[$match_result['category']] += $match_result['weight'];
            }
        }
    }
    
    // Chinese-specific keyword boost
    if ($this->has_chinese_characters($supplier_keywords)) {
        $keyword_score += $this->calculate_chinese_keyword_boost($supplier_keywords, $db_keywords);
    }
    
    // Add category match bonuses
    $keyword_score += $this->calculate_category_bonuses($category_matches);
    
    return $keyword_score;
}

/**
 * Match individual keywords
 * 
 * @param string $supplier_keyword Supplier keyword
 * @param string $db_keyword Database keyword
 * @return array Match result with score, category, and weight
 */
private function match_keywords($supplier_keyword, $db_keyword) {
    // Extract tag and value if present
    $supplier_parts = $this->parse_keyword($supplier_keyword);
    $db_parts = $this->parse_keyword($db_keyword);
    
    // Check for matches
    if (!empty($supplier_parts['tag']) && !empty($db_parts['tag']) && $supplier_parts['tag'] === $db_parts['tag']) {
        // Tags match, check values
        if ($supplier_parts['value'] === $db_parts['value']) {
            return array(
                'score' => 1.5,
                'category' => $this->get_keyword_category($supplier_parts['tag']),
                'weight' => 1.0
            );
        } else if (strpos($db_parts['value'], $supplier_parts['value']) !== false || 
                  strpos($supplier_parts['value'], $db_parts['value']) !== false) {
            return array(
                'score' => 0.75,
                'category' => $this->get_keyword_category($supplier_parts['tag']),
                'weight' => 0.5
            );
        }
    } else if (empty($supplier_parts['tag']) && empty($db_parts['tag'])) {
        // Both untagged
        if ($supplier_parts['value'] === $db_parts['value']) {
            return array('score' => 0.5, 'category' => 'generic', 'weight' => 1.0);
        } else if (strlen($supplier_parts['value']) > 3 && strlen($db_parts['value']) > 3 &&
                  (strpos($db_parts['value'], $supplier_parts['value']) !== false || 
                   strpos($supplier_parts['value'], $db_parts['value']) !== false)) {
            return array('score' => 0.25, 'category' => 'generic', 'weight' => 0.5);
        }
    } else if (!empty($supplier_parts['value']) && !empty($db_parts['value'])) {
        // One tagged, one untagged - compare values only
        if ($supplier_parts['value'] === $db_parts['value']) {
            return array('score' => 0.5, 'category' => 'generic', 'weight' => 1.0);
        } else if (strlen($supplier_parts['value']) > 3 && strlen($db_parts['value']) > 3 &&
                  (strpos($db_parts['value'], $supplier_parts['value']) !== false || 
                   strpos($supplier_parts['value'], $db_parts['value']) !== false)) {
            return array('score' => 0.25, 'category' => 'generic', 'weight' => 0.5);
        }
    }
    
    return array('score' => 0, 'category' => 'generic', 'weight' => 0);
}

/**
 * Parse keyword into tag and value components
 * 
 * @param string $keyword Keyword to parse
 * @return array Array with 'tag' and 'value' keys
 */
private function parse_keyword($keyword) {
    if (preg_match('/^([A-Z_]+):(.+)$/i', $keyword, $matches)) {
        return array(
            'tag' => strtoupper($matches[1]),
            'value' => strtolower(trim($matches[2]))
        );
    } else {
        return array(
            'tag' => '',
            'value' => strtolower(trim($keyword))
        );
    }
}

/**
 * Get keyword category from tag
 * 
 * @param string $tag Keyword tag
 * @return string Category name
 */
private function get_keyword_category($tag) {
    $category_map = array(
        'BRAND' => 'brand',
        'SERIES' => 'model',
        'VITOLA' => 'vitola',
        'SPECIAL' => 'special_edition',
        'YEAR' => 'year',
        'COUNT' => 'count',
        'DIM' => 'dimensions',
        'PACK' => 'packaging'
    );
    
    return $category_map[$tag] ?? 'generic';
}

/**
 * Check if keywords contain Chinese characters
 * 
 * @param array $keywords Keywords array
 * @return bool True if Chinese characters found
 */
private function has_chinese_characters($keywords) {
    foreach ($keywords as $keyword) {
        if (preg_match('/[\x{4e00}-\x{9fa5}]/u', $keyword)) {
            return true;
        }
    }
    return false;
}

/**
 * Calculate Chinese keyword matching boost
 * 
 * @param array $supplier_keywords Supplier keywords
 * @param array $db_keywords Database keywords
 * @return float Boost score
 */
private function calculate_chinese_keyword_boost($supplier_keywords, $db_keywords) {
    $boost = 0.0;
    
    foreach ($supplier_keywords as $supplier_keyword) {
        if (preg_match('/[\x{4e00}-\x{9fa5}]{2,}/u', $supplier_keyword)) {
            foreach ($db_keywords as $db_keyword) {
                if (strpos($db_keyword, $supplier_keyword) !== false || 
                    strpos($supplier_keyword, $db_keyword) !== false) {
                    $boost += 0.3;
                    break;
                }
            }
        }
    }
    
    return $boost;
}

/**
 * Calculate category match bonuses
 * 
 * @param array $category_matches Category match counts
 * @return float Bonus score
 */
private function calculate_category_bonuses($category_matches) {
    $bonus = 0.0;
    $bonus_weights = array(
        'brand' => 2.0, 'model' => 1.5, 'vitola' => 1.5, 'special_edition' => 1.0,
        'year' => 1.0, 'dimensions' => 1.0, 'count' => 0.5, 'packaging' => 0.5
    );
    
    foreach ($category_matches as $category => $count) {
        if ($count > 0 && isset($bonus_weights[$category])) {
            $bonus += $bonus_weights[$category] * $count;
        }
    }
    
    return $bonus;
}

/**
 * Calculate final weighted score
 * 
 * @param array $scores Score components
 * @return float Final normalized score
 */
/**
 * FIXED: Calculate final score with better weighting
 */
private function calculate_final_score($scores) {
    // Adjusted weights - brand and model are most important
    $score = ($scores['brand'] * 8.0) +      // Increased brand weight
            ($scores['model'] * 6.0) +       // Increased model weight
            ($scores['vitola'] * 4.0) +      
            ($scores['special'] * 3.0) + 
            ($scores['year'] * 3.0) + 
            ($scores['dimension'] * 3.0) + 
            ($scores['keyword'] * 1.0);      // Reduced keyword weight
    
    // Calculate maximum possible score with new weights
    $max_possible_score = (8.0 * 5.0) + (6.0 * 4.0) + (4.0 * 3.0) + 
                         (3.0 * 3.0) + (3.0 * 3.0) + (3.0 * 3.0) + 
                         (1.0 * 15.0);
    
    // Normalize score to 0-100 scale
    return min(100, round(($score / $max_possible_score) * 100, 1));
}
/**
 * Add this method to debug specific mismatches
 */
public function debug_specific_match($supplier_title, $db_sku) {
    $this->log_debug("=== DEBUG SPECIFIC MATCH ===");
    $this->log_debug("Supplier: $supplier_title");
    $this->log_debug("DB SKU: $db_sku");
    
    // Process supplier product
    $supplier_processed = $this->process_product_with_mappings($supplier_title);
    $this->log_debug("Supplier Brand: " . ($supplier_processed['brand'] ?? 'NONE'));
    $this->log_debug("Supplier Model: " . ($supplier_processed['model'] ?? 'NONE'));
    
    // Get DB product
    global $wpdb;
    $db_product = $wpdb->get_row($wpdb->prepare(
        "SELECT * FROM {$wpdb->prefix}kt_cigar_processed_keywords WHERE sku = %s",
        $db_sku
    ));
    
    if ($db_product) {
        $this->log_debug("DB Brand: " . $db_product->brand);
        $this->log_debug("DB Extracted Brand: " . $db_product->extracted_brand);
        $this->log_debug("DB Model: " . $db_product->extracted_model);
        
        // Check brand compatibility
        if (class_exists('KT_Cigar_Mappings')) {
            $same_brand = KT_Cigar_Mappings::is_same_brand(
                $supplier_processed['brand'] ?? '', 
                $db_product->brand
            );
            $this->log_debug("Same brand check: " . ($same_brand ? 'YES' : 'NO'));
        }
    }
    
    $this->log_debug("=== END DEBUG ===");
}

/**
 * Determine match type based on score and brand matching
 * 
 * @param float $normalized_score Normalized score
 * @param float $brand_score Brand score
 * @return string Match type
 */
/**
 * FIXED: Determine match type with stricter thresholds
 */
private function determine_match_type($normalized_score, $brand_score) {
    // No brand match = No match
    if ($brand_score < 3.0) {
        return "No Match";
    }
    
    // Stricter thresholds
    if ($normalized_score >= 90) {
        return "Exact Match";
    } else if ($normalized_score >= 75) {
        return "Close Match";
    } else if ($normalized_score >= 60) {
        return "Possible Match";
    } else {
        return "No Match";
    }
}


/**
 * Get matched terms between supplier and database data
 * 
 * @param array $supplier_data Supplier data
 * @param array $db_data Database data
 * @return array Matched terms
 */
private function get_matched_terms($supplier_data, $db_data) {
    $matched_terms = array();
    
    foreach ($supplier_data['keywords'] as $supplier_keyword) {
        if (strpos($supplier_keyword, 'FULL:') === 0) continue;
        
        foreach ($db_data['keywords'] as $db_keyword) {
            if (strpos($db_keyword, 'FULL:') === 0) continue;
            
            $match_result = $this->match_keywords($supplier_keyword, $db_keyword);
            if ($match_result['score'] > 0) {
                $matched_terms[] = $supplier_keyword;
                break;
            }
        }
    }
    
    return array_unique($matched_terms);
}

/**
 * Count database products
 * 
 * @param string $brand_filter Optional brand filter
 * @param string $sku_filter Optional SKU filter
 * @param string $title_filter Optional title filter
 * @return int Total count
 */
public function count_database_products($brand_filter = "", $sku_filter = "", $title_filter = "") {
    global $wpdb;
    
    // Build where clause
    $where = array("1=1");
    $params = array();
    
    if (!empty($brand_filter)) {
        $where[] = "brand = %s";
        $params[] = $brand_filter;
    }
    
    if (!empty($sku_filter)) {
        $where[] = "sku LIKE %s";
        $params[] = '%' . $wpdb->esc_like($sku_filter) . '%';
    }
    
    if (!empty($title_filter)) {
        $where[] = "product_title LIKE %s";
        $params[] = '%' . $wpdb->esc_like($title_filter) . '%';
    }
    
    // Add product type filter
    $where[] = "(product_type = 'cigar' OR product_type = '')";
    
    // Build query
    $query = "SELECT COUNT(*) 
             FROM {$wpdb->prefix}{$this->master_table} 
             WHERE " . implode(" AND ", $where);
    
    // Prepare and execute query
    if (!empty($params)) {
        $query = $wpdb->prepare($query, $params);
    }
    
    return (int)$wpdb->get_var($query);
}

/**
 * Get unique brands from database
 * 
 * @return array Array of brand names
 */
public function get_unique_brands() {
    global $wpdb;
    
    $query = "SELECT DISTINCT brand 
             FROM {$wpdb->prefix}{$this->master_table} 
             WHERE brand != '' AND (product_type = 'cigar' OR product_type = '') 
             ORDER BY brand ASC";
    
    return $wpdb->get_col($query);
}

/**
 * Get mappings for display
 * 
 * @param int $page Page number
 * @param int $per_page Items per page
 * @param string $supplier_filter Optional supplier filter
 * @param string $confidence_filter Optional confidence filter
 * @param string $search_filter Optional search filter
 * @return array Array of mapping objects
 */
public function get_mappings($current_page = 1, $per_page = 30, $supplier_filter = "", $confidence_filter = "", $search_filter = "") {
    global $wpdb;
    
    $offset = ($current_page - 1) * $per_page;
    
    // Build where clause
    $where = array("1=1");
    $params = array();
    
    if (!empty($supplier_filter)) {
        $where[] = "supplier_name = %s";
        $params[] = $supplier_filter;
    }
    
    if (!empty($confidence_filter)) {
        $where[] = "match_confidence = %s";
        $params[] = $confidence_filter;
    }
    
    if (!empty($search_filter)) {
        $where[] = "(supplier_title LIKE %s OR kt_sku LIKE %s OR matched_terms LIKE %s)";
        $search_like = '%' . $wpdb->esc_like($search_filter) . '%';
        $params[] = $search_like;
        $params[] = $search_like;
        $params[] = $search_like;
    }
    
    // Build query
    $query = "SELECT * 
             FROM {$wpdb->prefix}{$this->mapping_table} 
             WHERE " . implode(" AND ", $where) . " 
             ORDER BY supplier_name ASC, kt_sku ASC 
             LIMIT %d OFFSET %d";
    
    // Add pagination parameters
    $params[] = $per_page;
    $params[] = $offset;
    
    // Prepare and execute query
    $query = $wpdb->prepare($query, $params);
    
    return $wpdb->get_results($query);
}

/**
 * Count mappings
 * 
 * @param string $supplier_filter Optional supplier filter
 * @param string $confidence_filter Optional confidence filter
 * @param string $search_filter Optional search filter
 * @return int Total count
 */
public function count_mappings($supplier_filter = "", $confidence_filter = "", $search_filter = "") {
    global $wpdb;
    
    // Build where clause
    $where = array("1=1");
    $params = array();
    
    if (!empty($supplier_filter)) {
        $where[] = "supplier_name = %s";
        $params[] = $supplier_filter;
    }
    
    if (!empty($confidence_filter)) {
        $where[] = "match_confidence = %s";
        $params[] = $confidence_filter;
    }
    
    if (!empty($search_filter)) {
        $where[] = "(supplier_title LIKE %s OR kt_sku LIKE %s OR matched_terms LIKE %s)";
        $search_like = '%' . $wpdb->esc_like($search_filter) . '%';
        $params[] = $search_like;
        $params[] = $search_like;
        $params[] = $search_like;
    }
    
    // Build query
    $query = "SELECT COUNT(*) 
             FROM {$wpdb->prefix}{$this->mapping_table} 
             WHERE " . implode(" AND ", $where);
    
    // Prepare and execute query
    if (!empty($params)) {
        $query = $wpdb->prepare($query, $params);
    }
    
    return (int)$wpdb->get_var($query);
}



	
   
	
    
   
   
    /**
     * Save a mapping
     * 
     * @param string $supplier_id Supplier product ID
     * @param string $supplier_title Supplier product title
     * @param string $supplier_name Supplier name
     * @param string $kt_sku KT SKU
     * @param string $match_confidence Match confidence
     * @param string $matched_terms Matched terms
     * @return bool Success
     */
    public function save_mapping($supplier_id, $supplier_title, $supplier_name, $kt_sku, $match_confidence, $matched_terms = "") {
        global $wpdb;
        
        // Check if mapping already exists
        $existing = $wpdb->get_var($wpdb->prepare(
            "SELECT id FROM {$wpdb->prefix}{$this->mapping_table} 
            WHERE supplier_name = %s AND supplier_id = %s",
            $supplier_name, $supplier_id
        ));
        
        if ($existing) {
            // Update existing mapping
            $result = $wpdb->update(
                $wpdb->prefix . $this->mapping_table,
                array(
                    "kt_sku" => $kt_sku,
                    "match_confidence" => $match_confidence,
                    "matched_terms" => $matched_terms
                ),
                array(
                    "supplier_name" => $supplier_name,
                    "supplier_id" => $supplier_id
                )
            );
        } else {
            // Insert new mapping
            $result = $wpdb->insert(
                $wpdb->prefix . $this->mapping_table,
                array(
                    "supplier_id" => $supplier_id,
                    "supplier_name" => $supplier_name,
                    "supplier_title" => $supplier_title,
                    "kt_sku" => $kt_sku,
                    "match_confidence" => $match_confidence,
                    "matched_terms" => $matched_terms
                )
            );
            
            // Update supplier count
            $this->update_supplier_count($supplier_name);
        }
        
        return $result !== false;
    }
    
    /**
     * Update supplier mapping count
     * 
     * @param string $supplier_name Supplier name
     */
    private function update_supplier_count($supplier_name) {
        global $wpdb;
        
        // Get mapping count
        $count = $wpdb->get_var($wpdb->prepare(
            "SELECT COUNT(*) FROM {$wpdb->prefix}{$this->mapping_table} WHERE supplier_name = %s",
            $supplier_name
        ));
        
        // Check if supplier exists
        $supplier_id = $wpdb->get_var($wpdb->prepare(
            "SELECT id FROM {$wpdb->prefix}{$this->suppliers_table} WHERE supplier_name = %s",
            $supplier_name
        ));
        
        if ($supplier_id) {
            // Update existing supplier
            $wpdb->update(
                $wpdb->prefix . $this->suppliers_table,
                array("mapping_count" => $count),
                array("id" => $supplier_id)
            );
        } else {
            // Insert new supplier
            $wpdb->insert(
                $wpdb->prefix . $this->suppliers_table,
                array(
                    "supplier_name" => $supplier_name,
                    "supplier_description" => "",
                    "mapping_count" => $count
                )
            );
        }
    }


/**
 * Add this method to your KT_Cigar_Enhanced_Matcher class to debug why 
 * supplier vs database brand extraction differs
 */

public function debug_brand_extraction_comparison() {
    $this->log_debug("=== BRAND EXTRACTION COMPARISON DEBUG ===");
    
    // Test the same Chinese title in both contexts
    $test_title = "波尔 利昂 西班牙地限 10支 155*42 Leones";
    
    // 1. Test as if it's a supplier product
    $this->log_debug("--- TESTING AS SUPPLIER PRODUCT ---");
    if (class_exists('KT_Cigar_Mappings')) {
        $supplier_result = KT_Cigar_Mappings::process_supplier_product($test_title);
        $this->log_debug("Supplier processing - Brand: " . ($supplier_result["brand"] ?? "NONE"));
        $this->log_debug("Supplier processing - Keywords count: " . count($supplier_result["keywords"] ?? []));
        $this->log_debug("Supplier processing - Keywords: " . json_encode(array_slice($supplier_result["keywords"] ?? [], 0, 5)));
    } else {
        $this->log_debug("ERROR: KT_Cigar_Mappings not available for supplier test");
    }
    
    // 2. Test as if it's a database product  
    $this->log_debug("--- TESTING AS DATABASE PRODUCT ---");
    if (class_exists('KT_Cigar_Mappings')) {
        $db_result = KT_Cigar_Mappings::process_internal_product("TEST-SKU", $test_title, "42/155");
        $this->log_debug("Database processing - Brand: " . ($db_result["brand"] ?? "NONE"));
        $this->log_debug("Database processing - Keywords count: " . count($db_result["keywords"] ?? []));
        $this->log_debug("Database processing - Keywords: " . json_encode(array_slice($db_result["keywords"] ?? [], 0, 5)));
    } else {
        $this->log_debug("ERROR: KT_Cigar_Mappings not available for database test");
    }
    
    // 3. Check data file status at this moment
    $this->log_debug("--- DATA FILE STATUS CHECK ---");
    if (class_exists('KT_Cigar_Mappings')) {
        $data_file = KT_Cigar_Mappings::get_data_file();
        
        if (empty($data_file)) {
            $this->log_debug("CRITICAL: Data file is empty!");
        } else {
            $cuban_count = count($data_file['brands']['cuban'] ?? []);
            $non_cuban_count = count($data_file['brands']['non_cuban'] ?? []);
            $this->log_debug("Data file status: Cuban=$cuban_count, Non-Cuban=$non_cuban_count");
            
            // Check if the specific brand mapping exists
            $found_brand_mapping = false;
            
            // Check brand aliases
            if (isset($data_file['brand_aliases'])) {
                foreach ($data_file['brand_aliases'] as $alias => $brand) {
                    if (mb_stripos($alias, '波尔') !== false || mb_stripos($alias, '利昂') !== false) {
                        $this->log_debug("Found brand alias: '$alias' -> '$brand'");
                        $found_brand_mapping = true;
                    }
                }
            }
            
            // Check brand variations
            if (!$found_brand_mapping) {
                foreach (['cuban', 'non_cuban'] as $section) {
                    if (isset($data_file['brands'][$section])) {
                        foreach ($data_file['brands'][$section] as $brand => $variations) {
                            foreach ($variations as $variation) {
                                if (mb_stripos($variation, '波尔') !== false || mb_stripos($variation, '利昂') !== false) {
                                    $this->log_debug("Found brand variation: '$variation' -> '$brand' in $section");
                                    $found_brand_mapping = true;
                                    break 2;
                                }
                            }
                        }
                    }
                }
            }
            
            if (!$found_brand_mapping) {
                $this->log_debug("PROBLEM: No brand mapping found for '波尔 利昂' in data file!");
                
                // Show some sample brand aliases for comparison
                $this->log_debug("Sample brand aliases:");
                if (isset($data_file['brand_aliases'])) {
                    $count = 0;
                    foreach ($data_file['brand_aliases'] as $alias => $brand) {
                        if ($count < 5) {
                            $this->log_debug("  '$alias' -> '$brand'");
                            $count++;
                        }
                    }
                }
            }
        }
    }
    
    // 4. Test direct brand extraction on the problematic title
    $this->log_debug("--- DIRECT BRAND EXTRACTION TEST ---");
    $this->test_specific_brand_extraction($test_title);
    
    $this->log_debug("=== END BRAND EXTRACTION COMPARISON ===");
}
/**
 * Test specific brand extraction with detailed logging
 */
private function test_specific_brand_extraction($title) {
    // Force load before processing - check if KT_Cigar_Mappings is available
    if (!class_exists('KT_Cigar_Mappings')) {
        $this->log_debug("KT_Cigar_Mappings not available, using fallback");
        return array("keywords" => array("FULL:" . strtolower($title)));
    }
    
    // Force initialization
    KT_Cigar_Mappings::init(true);
    
    $data_file = KT_Cigar_Mappings::get_data_file();
    $normalized_title = mb_strtolower(trim($title));
    
    $this->log_debug("Testing brand extraction for: '$title'");
    $this->log_debug("Normalized title: '$normalized_title'");
    
    $extracted_brand = null;
    
    // Test brand aliases (exact same logic as in KT_Cigar_Mappings)
    if (!empty($data_file['brand_aliases'])) {
        $this->log_debug("Checking " . count($data_file['brand_aliases']) . " brand aliases...");
        
        foreach ($data_file['brand_aliases'] as $alias => $english_brand) {
            if (mb_stripos($normalized_title, mb_strtolower($alias)) !== false) {
                $extracted_brand = $english_brand;
                $this->log_debug("FOUND via alias: '$alias' -> '$english_brand'");
                break;
            }
        }
    } else {
        $this->log_debug("No brand aliases in data file");
    }
    
    // Test brand variations if no alias match
    if (empty($extracted_brand)) {
        $this->log_debug("No alias match, checking brand variations...");
        
        foreach (['cuban', 'non_cuban'] as $section) {
            if (isset($data_file['brands'][$section])) {
                $this->log_debug("Checking $section brands (" . count($data_file['brands'][$section]) . " brands)");
                
                foreach ($data_file['brands'][$section] as $brand => $variations) {
                    // Check main brand name
                    if (mb_stripos($normalized_title, mb_strtolower($brand)) !== false) {
                        $extracted_brand = $brand;
                        $this->log_debug("FOUND via main brand name: '$brand'");
                        break 2;
                    }
                    
                    // Check variations
                    foreach ($variations as $variation) {
                        if (mb_stripos($normalized_title, mb_strtolower($variation)) !== false) {
                            $extracted_brand = $brand;
                            $this->log_debug("FOUND via variation: '$variation' -> '$brand'");
                            break 3;
                        }
                    }
                }
            }
        }
    }
    
    if (empty($extracted_brand)) {
        $this->log_debug("FAILED: No brand found for '$title'");
        
        // Show what we were looking for
        $this->log_debug("Title contains Chinese characters: " . (preg_match('/[\x{4e00}-\x{9fa5}]/u', $title) ? 'YES' : 'NO'));
        
        // Show some sample searches that might have worked
        $this->log_debug("Sample alias searches that would work:");
        if (!empty($data_file['brand_aliases'])) {
            $count = 0;
            foreach ($data_file['brand_aliases'] as $alias => $brand) {
                if (preg_match('/[\x{4e00}-\x{9fa5}]/u', $alias) && $count < 3) {
                    $this->log_debug("  If title contained '$alias' -> would extract '$brand'");
                    $count++;
                }
            }
        }
    } else {
        $this->log_debug("SUCCESS: Extracted brand '$extracted_brand'");
    }
}

/**
 * AJAX handler for the brand extraction comparison debug
 */
public function ajax_debug_brand_comparison() {
    check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
    
    if (!current_user_can("manage_options")) {
        wp_send_json_error(array("message" => "Insufficient permissions"));
    }
    
    $this->debug_brand_extraction_comparison();
    
    wp_send_json_success(array(
        "message" => "Brand extraction comparison completed - check debug log",
        "log_file" => WP_CONTENT_DIR . '/cigar-matcher-debug.log'
    ));
}	
	
	
	
	
	
	
	
	
	
	
	
  /**
 * Clean up expired sessions
 */
private function cleanup_expired_sessions() {
    $active_sessions = get_option('kt_cigar_matcher_active_sessions', array());
    $valid_sessions = array();
    
    foreach ($active_sessions as $session_key) {
        $session_data = get_transient($session_key);
        if ($session_data) {
            $valid_sessions[] = $session_key;
        }
    }
    
    update_option('kt_cigar_matcher_active_sessions', $valid_sessions);
    $this->log_debug("Cleaned up sessions. Valid sessions: " . implode(", ", $valid_sessions));
}
	
	
	
	
	
    /**
     * Process CSV header
     * 
     * @param array $header CSV header row
     * @param array $mapping Column mapping
     * @return array Processed header with mapping
     */
    private function process_csv_header($header, $mapping = null) {
        $processed_header = array();
        
        // Check if we have a mapping
        if (!empty($mapping) && is_array($mapping)) {
            foreach ($header as $index => $field) {
                // Clean field name
                $field = trim($field);
                
                // Find mapping for this field
                $mapped_field = "skip";
                foreach ($mapping as $map) {
                    if (isset($map["csv_column"]) && $map["csv_column"] === $field) {
                        $mapped_field = $map["kt_field"];
                        break;
                    }
                }
                
                $processed_header[$index] = array(
                    "original" => $field,
                    "mapped" => $mapped_field
                );
            }
        } else {
            // Auto-detect field mapping
            foreach ($header as $index => $field) {
                // Clean field name
                $field = trim($field);
                
                // Determine field type
                $mapped_field = "skip";
                $field_lower = strtolower($field);
                
                // ID field detection
                if ($field_lower === "id" || $field_lower === "product_id" || $field_lower === "item_id") {
                    $mapped_field = "id";
                }
                // Title field detection
                else if ($field_lower === "title" || $field_lower === "product_title" || $field_lower === "name" || $field_lower === "product_name") {
                    $mapped_field = "title";
                }
                // Brand field detection
                else if ($field_lower === "brand" || $field_lower === "manufacturer" || $field_lower === "maker") {
                    $mapped_field = "brand";
                }
                // Model field detection
                else if ($field_lower === "model" || $field_lower === "series" || $field_lower === "line") {
                    $mapped_field = "model";
                }
                // Ring gauge field detection
                else if ($field_lower === "ring" || $field_lower === "ring_gauge" || $field_lower === "gauge" || $field_lower === "rg") {
                    $mapped_field = "ring_gauge";
                }
               // Handle "Ring Size" from your CSV
else if ($field_lower === "ring size" || $field_lower === "ringsize") {
    $mapped_field = "ring_gauge";
}
// Handle "Image URL" from your CSV
else if ($field_lower === "image url" || $field_lower === "imageurl" || $field_lower === "image_url") {
    $mapped_field = "image_url";
} 
				
				
				// Length field detection
                else if ($field_lower === "length" || $field_lower === "len") {
                    $mapped_field = "length";
                }
                // Price field detection
                else if ($field_lower === "price" || $field_lower === "cost" || $field_lower === "unit_price") {
                    $mapped_field = "price";
                }
                // Description field detection
                else if ($field_lower === "description" || $field_lower === "desc" || $field_lower === "product_description") {
                    $mapped_field = "description";
                }
                // Stock field detection
                else if ($field_lower === "stock" || $field_lower === "quantity" || $field_lower === "qty" || $field_lower === "inventory") {
                    $mapped_field = "stock";
                }
                
                $processed_header[$index] = array(
                    "original" => $field,
                    "mapped" => $mapped_field
                );
            }
        }
        
        return $processed_header;
    }
  /**
 * Debug keyword extraction process
 */
public function debug_keyword_extraction() {
    $this->log_debug("=== DEBUGGING KEYWORD EXTRACTION ===");
    
    // Test KT_Cigar_Mappings availability
    $kt_available = class_exists('KT_Cigar_Mappings');
    $this->log_debug("KT_Cigar_Mappings available: " . ($kt_available ? 'YES' : 'NO'));
    
    if ($kt_available) {
        // Test processing
        $test_result = KT_Cigar_Mappings::process_internal_product("TEST-001", "Cohiba Robusto", "50/124");
        $this->log_debug("Test processing result keywords: " . count($test_result["keywords"] ?? []));
    }
    
    // Check cache
    $cache_key = 'kt_cigar_processed_db_products_v2';
    delete_transient($cache_key); // Force fresh processing
    
    $fresh_data = $this->preprocess_all_database_products();
    $products_with_keywords = 0;
    
    foreach ($fresh_data as $sku => $product) {
        if (!empty($product['keywords'])) {
            $products_with_keywords++;
        }
    }
    
    $this->log_debug("RESULT: $products_with_keywords/" . count($fresh_data) . " products have keywords");
    return array(
  
		'kt_mappings_available' => $kt_available,
        'test_keywords_extracted' => 0,

   
		'cache_was_populated' => isset($cache_status) ? $cache_status : false,
    'cache_product_count' => isset($cache_count) ? $cache_count : 0,
    'total_products_processed' => count($fresh_data),
    'products_with_keywords' => $products_with_keywords,
    'total_keywords_extracted' => isset($total_keywords) ? $total_keywords : 0,
    'sample_products' => isset($sample_products) ? $sample_products : array()
);
	
	
}
	
	
	
	
	
	
    /* AJAX HANDLERS */
    
    /**
     * AJAX handler for uploading supplier CSV
     */
    public function ajax_upload_supplier_csv() {
     // Clean up expired sessions before creating a new one
$this->cleanup_expired_sessions();
		 // Add debug logging
    $this->log_debug("=== CSV UPLOAD START ===");
    $this->log_debug("POST data: " . json_encode($_POST));
    $this->log_debug("FILES data: " . json_encode($_FILES));
		
		
		check_ajax_referer("kt-cigar-matcher-nonce", "kt_cigar_matcher_nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get supplier name
        $supplier_name = isset($_POST["supplier_name"]) ? sanitize_text_field($_POST["supplier_name"]) : "";
        
        if (empty($supplier_name)) {
            wp_send_json_error(array("message" => "Supplier name is required"));
        }
        
        $this->log_debug("Processing CSV upload for supplier: " . $supplier_name);
        
        // Check if a file was uploaded
        if (!isset($_FILES["supplier_csv"]) || $_FILES["supplier_csv"]["error"] !== UPLOAD_ERR_OK) {
            $this->log_debug("No file uploaded or error: " . ($_FILES["supplier_csv"]["error"] ?? "unknown"));
            wp_send_json_error(array("message" => "No file uploaded or error"));
        }
       // Validate file type
        $file_type = wp_check_filetype(basename($_FILES["supplier_csv"]["name"]), array("csv" => "text/csv"));
        
        if ($file_type["type"] !== "text/csv") {
            $this->log_debug("Invalid file type: " . ($file_type["type"] ?? "unknown"));
            wp_send_json_error(array("message" => "Invalid file type. Please upload a CSV file."));
        }
        
        // Create upload directory if it doesn't exist
        $upload_dir = wp_upload_dir();
        $supplier_dir = $upload_dir["basedir"] . "/cigar-supplier-csv";
        
        if (!file_exists($supplier_dir)) {
            if (!wp_mkdir_p($supplier_dir)) {
                $this->log_debug("Failed to create directory: " . $supplier_dir);
                wp_send_json_error(array("message" => "Failed to create upload directory"));
            }
        }
        
        // Generate unique filename
        $filename = sanitize_file_name($supplier_name . "-" . date("Y-m-d-H-i-s") . ".csv");
        $file_path = $supplier_dir . "/" . $filename;
        
        // Move uploaded file
        if (!move_uploaded_file($_FILES["supplier_csv"]["tmp_name"], $file_path)) {
            $this->log_debug("Failed to move uploaded file to: " . $file_path);
            wp_send_json_error(array("message" => "Failed to upload file"));
        }
        
        // Process CSV file
        $csv_data = array();
        
        // Open file
        $handle = fopen($file_path, "r");
        
        if ($handle === false) {
            $this->log_debug("Failed to open file: " . $file_path);
            wp_send_json_error(array("message" => "Failed to read CSV file"));
        }
        
        // Read header row
        $header = fgetcsv($handle);
        
        if ($header === false) {
            $this->log_debug("Failed to read CSV header");
            fclose($handle);
            wp_send_json_error(array("message" => "Failed to read CSV header"));
        }
        
        // Try to load a template for this supplier
        global $wpdb;
        $template = $wpdb->get_row($wpdb->prepare(
            "SELECT column_mappings FROM {$wpdb->prefix}{$this->template_table} WHERE supplier_name = %s ORDER BY updated_at DESC LIMIT 1",
            $supplier_name
        ));
        
        $column_mapping = null;
        
        if ($template && !empty($template->column_mappings)) {
            $column_mapping = json_decode($template->column_mappings, true);
        }
        
        // Process header
        $processed_header = $this->process_csv_header($header, $column_mapping);
        
        // Setup session variable for storing data
        $session_key = "kt_cigar_matcher_" . md5($supplier_name . time());
        
        // Check if we have the necessary columns
        $has_id = false;
        $has_title = false;
        
        foreach ($processed_header as $field) {
            if ($field["mapped"] === "id") {
                $has_id = true;
            } else if ($field["mapped"] === "title") {
                $has_title = true;
            }
        }
        
        if (!$has_id || !$has_title) {
            $this->log_debug("Missing required columns: ID and/or Title");
            fclose($handle);
            wp_send_json_error(array("message" => "CSV file must contain ID and Title columns"));
        }
        
        // Read data rows
        $row_count = 0;
        $data_rows = array();
        
        while (($row = fgetcsv($handle)) !== false) {
            $row_data = array();
            
            // Process each field according to mapping
            foreach ($processed_header as $index => $field) {
                if (isset($row[$index])) {
                    $value = trim($row[$index]);
                    
                    // Only add fields that are mapped
                    if ($field["mapped"] !== "skip") {
                        $row_data[$field["mapped"]] = $value;
                    }
                }
            }
           // Only add rows with ID and Title
if (!empty($row_data["id"]) && !empty($row_data["title"])) {
    $data_rows[] = $row_data;
    $row_count++;
}
      
		}
		
        
        fclose($handle);
        
        // Store data in session
        set_transient($session_key, array(
            "supplier_name" => $supplier_name,
            "file_path" => $file_path,
            "header" => $processed_header,
            "data" => $data_rows,
            "total_rows" => $row_count,
            "processed_rows" => 0
        ), 60 * 60 * 2); // 2 hour expiration
        
        $this->log_debug("CSV file processed with $row_count products. Session key: $session_key");
        // Store session key in active sessions
$active_sessions = get_option('kt_cigar_matcher_active_sessions', array());
$active_sessions[] = $session_key;
update_option('kt_cigar_matcher_active_sessions', $active_sessions);

$this->log_debug("Added session key to active sessions: $session_key");
		
		
		
		
        // Return success with session key
        wp_send_json_success(array(
            "message" => "CSV file uploaded successfully with $row_count products",
            "session_key" => $session_key,
            "total_rows" => $row_count
        ));
    }
    
    /**
     * AJAX handler for checking session status
     */
    public function ajax_check_status() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Check for errors
        $errors = array();
        
        // Check required tables
        global $wpdb;
        $master_table = $wpdb->prefix . $this->master_table;
        
        if ($wpdb->get_var("SHOW TABLES LIKE '$master_table'") != $master_table) {
            $errors[] = "Master products table does not exist";
        }
        
        // Check data file
        $data_file = $this->load_data_file();
        
        if (empty($data_file)) {
            $errors[] = "Data file is missing or empty";
        }
        
        // Return status
        wp_send_json_success(array(
            "has_errors" => !empty($errors),
            "message" => implode(", ", $errors),
            "debug_log" => array_slice($this->debug_log, -10)
        ));
    }
    
    /**
     * AJAX handler for processing a batch of products
     */
    public function ajax_process_batch_products() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $position = isset($_POST["position"]) ? intval($_POST["position"]) : 0;
        $batch_size = isset($_POST["batch_size"]) ? intval($_POST["batch_size"]) : 10;
        
        // Get session data
        $session_keys = get_option('kt_cigar_matcher_active_sessions', array());
        $session_key = end($session_keys);
        
        if (!$session_key) {
            $this->log_debug("No active session found");
            wp_send_json_error(array("message" => "No active session found"));
        }
        
        $session_data = get_transient($session_key);
        
        if (!$session_data) {
            $this->log_debug("Session expired or not found: $session_key");
            wp_send_json_error(array("message" => "Session expired or not found"));
        }
        
        // Get batch of products
        $start = $position;
        $end = min($position + $batch_size, count($session_data["data"]));
        
        $this->log_debug("Processing batch from $start to $end of {$session_data["total_rows"]} products");
        
        if ($start >= $end) {
         
		// Right before wp_send_json_success, add:
foreach ($batch_results as $i => $result) {
    if (isset($result["best_match"]["db_keywords"])) {
        $this->log_debug("FINAL BATCH[$i]: " . count($result["best_match"]["db_keywords"]) . " db_keywords will be sent to client");
    } else {
        $this->log_debug("FINAL BATCH[$i]: NO db_keywords field found");
    }
}	
			
			
			
			
			
			
			
			
			// All products processed
            wp_send_json_success(array(
                "completed" => true,
                "position" => $end,
                "total" => $session_data["total_rows"],
                "percentage" => 100
            ));
        }
        
        // Process batch
        $batch_results = array();
        $match_counts = array(
            "exact" => 0,
            "close" => 0,
            "possible" => 0,
            "manual" => 0,
            "none" => 0
        );
        for ($i = $start; $i < $end; $i++) {
    $product = $session_data["data"][$i];
    
    // Process the product
    $process_result = $this->process_supplier_product($product, $session_data["supplier_name"]);
    
    // Save mapping if we have a match
    if ($process_result["match_status"] !== "no_match" && !empty($process_result["best_match"])) {
        $match_confidence = "none";
        
        // Use the new status names
        switch ($process_result["match_status"]) {
            case "exact_match":
                $match_confidence = "exact";
                break;
            case "close_match":
                $match_confidence = "close";
                break;
            case "possible_match":
                $match_confidence = "possible";
                break;
        }
                
                // Save the mapping
                $matched_terms = is_array($process_result["matched_terms"]) ? 
                                implode(',', $process_result["matched_terms"]) : 
                                $process_result["matched_terms"];
                
                $this->save_mapping(
                    $process_result["product_id"],
                    $process_result["product_title"],
                    $session_data["supplier_name"],
                    $process_result["best_match"]["sku"],
                    $match_confidence,
                    $matched_terms
                );
            }
            
            // Update match counts
            switch ($process_result["match_status"]) {
                case "exact_match":
                    $match_counts["exact"]++;
                    break;
                case "close_match":
                    $match_counts["close"]++;
                    break;
                case "possible_match":
                    $match_counts["possible"]++;
                    break;
                case "manual_match":
                    $match_counts["manual"]++;
                    break;
                default:
                    $match_counts["none"]++;
            }
          // Ensure db_keywords are preserved for client display
if (isset($process_result["best_match"]) && isset($process_result["best_match"]["db_keywords"])) {
    $this->log_debug("BATCH RESULT: Preserving " . count($process_result["best_match"]["db_keywords"]) . " DB keywords for client");
} else {
    $this->log_debug("BATCH RESULT: No DB keywords found to preserve");
}

// Add to batch results
$batch_results[] = $process_result;
			
        }
        
        // Update session data
        $session_data["processed_rows"] = $end;
        set_transient($session_key, $session_data, 60 * 60 * 2); // 2 hour expiration
        
        // Calculate percentage
        $percentage = round(($end / $session_data["total_rows"]) * 100);
        
        $this->log_debug("Batch processing complete. Match counts: " . json_encode($match_counts));
        
        // Return results
        wp_send_json_success(array(
            "completed" => $end >= $session_data["total_rows"],
            "position" => $end,
            "total" => $session_data["total_rows"],
            "percentage" => $percentage,
            "batch_results" => $batch_results,
            "match_counts" => $match_counts
        ));
    }
    
    /**
     * AJAX handler for saving a mapping
     */
    public function ajax_save_mapping() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $supplier_id = isset($_POST["supplier_id"]) ? sanitize_text_field($_POST["supplier_id"]) : "";
        $supplier_title = isset($_POST["supplier_title"]) ? sanitize_text_field($_POST["supplier_title"]) : "";
        $supplier_name = isset($_POST["supplier_name"]) ? sanitize_text_field($_POST["supplier_name"]) : "";
        $kt_sku = isset($_POST["kt_sku"]) ? sanitize_text_field($_POST["kt_sku"]) : "";
        
        if (empty($supplier_id) || empty($supplier_name) || empty($kt_sku)) {
            wp_send_json_error(array("message" => "Missing required parameters"));
        }
        
        // Save the mapping
        $result = $this->save_mapping(
            $supplier_id,
            $supplier_title,
            $supplier_name,
            $kt_sku,
            "manual",
            ""
        );
        
        if ($result) {
            $this->log_debug("Manual mapping saved: $supplier_id -> $kt_sku");
            wp_send_json_success(array("message" => "Mapping saved successfully"));
        } else {
            $this->log_debug("Failed to save manual mapping: $supplier_id -> $kt_sku");
            wp_send_json_error(array("message" => "Failed to save mapping"));
        }
    }
    
    /**
     * AJAX handler for deleting a mapping
     */
    public function ajax_delete_mapping() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $mapping_id = isset($_POST["mapping_id"]) ? intval($_POST["mapping_id"]) : 0;
        
        if ($mapping_id <= 0) {
            wp_send_json_error(array("message" => "Invalid mapping ID"));
        }
        
        // Delete the mapping
        global $wpdb;
        $result = $wpdb->delete(
            $wpdb->prefix . $this->mapping_table,
            array("id" => $mapping_id)
        );
        
        if ($result) {
            $this->log_debug("Mapping deleted: $mapping_id");
            wp_send_json_success(array("message" => "Mapping deleted successfully"));
        } else {
            $this->log_debug("Failed to delete mapping: $mapping_id");
            wp_send_json_error(array("message" => "Failed to delete mapping"));
        }
    }
    
    /**
     * AJAX handler for exporting mappings
     */
    public function ajax_export_mappings() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $supplier = isset($_POST["supplier"]) ? sanitize_text_field($_POST["supplier"]) : "";
        
        if (empty($supplier)) {
            wp_send_json_error(array("message" => "Supplier name is required"));
        }
        
        // Get mappings
        global $wpdb;
        $mappings = $wpdb->get_results($wpdb->prepare(
            "SELECT m.supplier_id, m.supplier_title, m.kt_sku, m.match_confidence, p.product_title 
            FROM {$wpdb->prefix}{$this->mapping_table} m 
            LEFT JOIN {$wpdb->prefix}{$this->master_table} p ON m.kt_sku = p.sku 
            WHERE m.supplier_name = %s 
            ORDER BY m.supplier_id ASC",
            $supplier
        ));
        
        if (empty($mappings)) {
            wp_send_json_error(array("message" => "No mappings found for this supplier"));
        }
        
        // Generate CSV
        $csv = "Supplier ID,Supplier Title,KT SKU,KT Title,Match Confidence\n";
        
        foreach ($mappings as $mapping) {
            $csv .= '"' . str_replace('"', '""', $mapping->supplier_id) . '",';
            $csv .= '"' . str_replace('"', '""', $mapping->supplier_title) . '",';
            $csv .= '"' . str_replace('"', '""', $mapping->kt_sku) . '",';
            $csv .= '"' . str_replace('"', '""', $mapping->product_title ?? "") . '",';
            $csv .= '"' . str_replace('"', '""', ucfirst($mapping->match_confidence)) . '"' . "\n";
        }
        
        // Generate filename
        $filename = sanitize_file_name($supplier . "-mappings-" . date("Y-m-d") . ".csv");
        
        $this->log_debug("Exported " . count($mappings) . " mappings for $supplier");
        
        // Return CSV data
        wp_send_json_success(array(
            "csv" => $csv,
            "filename" => $filename
        ));
    }
    
    /**
     * AJAX handler for saving a template
     */
    public function ajax_save_template() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $template_id = isset($_POST["template_id"]) ? intval($_POST["template_id"]) : 0;
        $template_name = isset($_POST["template_name"]) ? sanitize_text_field($_POST["template_name"]) : "";
        $supplier_name = isset($_POST["supplier_name"]) ? sanitize_text_field($_POST["supplier_name"]) : "";
        $column_mappings = isset($_POST["column_mappings"]) ? $_POST["column_mappings"] : "";
        
        if (empty($template_name) || empty($supplier_name) || empty($column_mappings)) {
            wp_send_json_error(array("message" => "Missing required parameters"));
        }
        
        // Parse column mappings
        $column_mappings_json = json_decode($column_mappings, true);
        
        if (!is_array($column_mappings_json)) {
            wp_send_json_error(array("message" => "Invalid column mappings format"));
        }
        
        // Save template
        global $wpdb;
        
        if ($template_id > 0) {
            // Update existing template
            $result = $wpdb->update(
                $wpdb->prefix . $this->template_table,
                array(
                    "template_name" => $template_name,
                    "supplier_name" => $supplier_name,
                    "column_mappings" => $column_mappings
                ),
                array("id" => $template_id)
            );
        } else {
            // Check if template name already exists
            $exists = $wpdb->get_var($wpdb->prepare(
                "SELECT id FROM {$wpdb->prefix}{$this->template_table} WHERE template_name = %s",
                $template_name
            ));
            
            if ($exists) {
                wp_send_json_error(array("message" => "Template name already exists"));
            }
            
            // Insert new template
            $result = $wpdb->insert(
                $wpdb->prefix . $this->template_table,
                array(
                    "template_name" => $template_name,
                    "supplier_name" => $supplier_name,
                    "column_mappings" => $column_mappings
                )
            );
        }
        
        if ($result) {
            $this->log_debug("Template saved: $template_name for $supplier_name");
            wp_send_json_success(array("message" => "Template saved successfully"));
        } else {
            $this->log_debug("Failed to save template: $template_name");
            wp_send_json_error(array("message" => "Failed to save template"));
        }
    }
    
    /**
     * AJAX handler for loading a template
     */
    public function ajax_load_template() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $template_id = isset($_POST["template_id"]) ? intval($_POST["template_id"]) : 0;
        
        if ($template_id <= 0) {
            wp_send_json_error(array("message" => "Invalid template ID"));
        }
        
        // Get template
        global $wpdb;
        $template = $wpdb->get_row($wpdb->prepare(
            "SELECT * FROM {$wpdb->prefix}{$this->template_table} WHERE id = %d",
            $template_id
        ));
        
        if (!$template) {
            wp_send_json_error(array("message" => "Template not found"));
        }
        
        // Return template data
        wp_send_json_success(array(
            "id" => $template->id,
            "template_name" => $template->template_name,
            "supplier_name" => $template->supplier_name,
            "column_mappings" => $template->column_mappings
        ));
    }
    
    /**
     * AJAX handler for deleting a template
     */
    public function ajax_delete_template() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $template_id = isset($_POST["template_id"]) ? intval($_POST["template_id"]) : 0;
        
        if ($template_id <= 0) {
            wp_send_json_error(array("message" => "Invalid template ID"));
        }
        
        // Delete template
        global $wpdb;
        $result = $wpdb->delete(
            $wpdb->prefix . $this->template_table,
            array("id" => $template_id)
        );
        
        if ($result) {
            $this->log_debug("Template deleted: $template_id");
            wp_send_json_success(array("message" => "Template deleted successfully"));
        } else {
            $this->log_debug("Failed to delete template: $template_id");
            wp_send_json_error(array("message" => "Failed to delete template"));
        }
  
	

	}

	
	
	
	
    /**
     * AJAX handler for listing templates
     */
    public function ajax_list_templates() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get templates
        global $wpdb;
        $templates = $wpdb->get_results(
            "SELECT id, template_name, supplier_name FROM {$wpdb->prefix}{$this->template_table} ORDER BY template_name ASC"
        );
        
        // Return templates
        wp_send_json_success(array("templates" => $templates));
    }
    
    /**
     * AJAX handler for searching by SKU
     */
    public function ajax_search_sku() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $search = isset($_POST["search"]) ? sanitize_text_field($_POST["search"]) : "";
        
        if (empty($search)) {
            wp_send_json_error(array("message" => "Search term is required"));
        }
        
        // Search products
        global $wpdb;
        $products = $wpdb->get_results($wpdb->prepare(
            "SELECT sku, product_title FROM {$wpdb->prefix}{$this->master_table} 
            WHERE (sku LIKE %s OR product_title LIKE %s) 
            AND (product_type = 'cigar' OR product_type = '') 
            ORDER BY brand ASC, sku ASC 
            LIMIT 50",
            "%" . $wpdb->esc_like($search) . "%",
            "%" . $wpdb->esc_like($search) . "%"
        ));
        
        $this->log_debug("SKU search for '$search' returned " . count($products) . " results");
        
        // Return products
        wp_send_json_success(array("products" => $products));
    }
    
    /**
     * AJAX handler for searching by brand
     */
    public function ajax_search_by_brand() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $brand = isset($_POST["brand"]) ? sanitize_text_field($_POST["brand"]) : "";
        
        if (empty($brand)) {
            wp_send_json_error(array("message" => "Brand is required"));
        }
        
        // Search products
        global $wpdb;
        $products = $wpdb->get_results($wpdb->prepare(
            "SELECT sku, product_title FROM {$wpdb->prefix}{$this->master_table} 
            WHERE (brand LIKE %s OR product_title LIKE %s) 
            AND (product_type = 'cigar' OR product_type = '') 
            ORDER BY sku ASC 
            LIMIT 50",
            "%" . $wpdb->esc_like($brand) . "%",
            "%" . $wpdb->esc_like($brand) . "%"
        ));
        
        $this->log_debug("Brand search for '$brand' returned " . count($products) . " results");
        
        // Return products
        wp_send_json_success(array("products" => $products));
   
	}
   
	
	
	
	/**
 * AJAX handler for debugging keyword extraction
 */
public function ajax_debug_keywords() {
    check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
    
    if (!current_user_can("manage_options")) {
        wp_send_json_error(array("message" => "Insufficient permissions"));
    }
    
    $debug_results = $this->debug_keyword_extraction(); // This method already exists
    
    wp_send_json_success(array(
        "message" => "Debug completed - check results below",
        "results" => $debug_results
    ));
}

/**
 * AJAX handler for clearing product cache
 */
public function ajax_clear_cache() {
    check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
    
    if (!current_user_can("manage_options")) {
        wp_send_json_error(array("message" => "Insufficient permissions"));
    }
    
    $cache_key = 'kt_cigar_processed_db_products_v2';
    delete_transient($cache_key);
    
    wp_send_json_success(array(
        "message" => "Product cache cleared successfully"
    ));
}
	
	
	
	
	
	
	
	/**
 * AJAX handler for checking keywords table status
 */
public function ajax_check_keywords_table() {
    check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
    
    if (!current_user_can("manage_options")) {
        wp_send_json_error(array("message" => "Insufficient permissions"));
    }
    
    $status = $this->check_keywords_table_status();
    
    wp_send_json_success(array(
        "message" => "Keywords table status checked",
        "status" => $status
    ));
}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
    /**
     * AJAX handler for quick mapping
     */
    public function ajax_quick_map() {
        check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
        
        if (!current_user_can("manage_options")) {
            wp_send_json_error(array("message" => "Insufficient permissions"));
        }
        
        // Get parameters
        $supplier_id = isset($_POST["supplier_id"]) ? sanitize_text_field($_POST["supplier_id"]) : "";
        $kt_sku = isset($_POST["kt_sku"]) ? sanitize_text_field($_POST["kt_sku"]) : "";
        
        if (empty($supplier_id) || empty($kt_sku)) {
            wp_send_json_error(array("message" => "Missing required parameters"));
        }
        
        // Get session data
        $session_keys = get_option('kt_cigar_matcher_active_sessions', array());
        $session_key = end($session_keys);
        
        if (!$session_key) {
            $this->log_debug("No active session found for quick map");
            wp_send_json_error(array("message" => "No active session found"));
        }
        
        $session_data = get_transient($session_key);
        
        if (!$session_data) {
            $this->log_debug("Session expired or not found for quick map: $session_key");
            wp_send_json_error(array("message" => "Session expired or not found"));
        }
        
        // Find supplier product
        $supplier_product = null;
        
        foreach ($session_data["data"] as $product) {
            if ($product["id"] === $supplier_id) {
                $supplier_product = $product;
                break;
            }
        }
        
        if (!$supplier_product) {
            $this->log_debug("Supplier product not found for ID: $supplier_id");
            wp_send_json_error(array("message" => "Supplier product not found"));
        }
        
        // Get KT product title
        global $wpdb;
        $kt_product = $wpdb->get_row($wpdb->prepare(
            "SELECT product_title FROM {$wpdb->prefix}{$this->master_table} WHERE sku = %s",
            $kt_sku
        ));
        
        if (!$kt_product) {
            $this->log_debug("KT product not found for SKU: $kt_sku");
            wp_send_json_error(array("message" => "KT product not found"));
        }
        
        // Save the mapping
        $result = $this->save_mapping(
            $supplier_id,
            $supplier_product["title"],
            $session_data["supplier_name"],
            $kt_sku,
            "manual"
        );
        
        if ($result) {
            $this->log_debug("Quick map saved: $supplier_id -> $kt_sku");
            wp_send_json_success(array(
                "message" => "Mapping saved successfully",
                "kt_title" => $kt_product->product_title
            ));
        } else {
            $this->log_debug("Failed to save quick map: $supplier_id -> $kt_sku");
            wp_send_json_error(array("message" => "Failed to save mapping"));
     
		}
 

	}
/**
 * AJAX handler for getting DB keywords by SKU
 */
public function ajax_get_db_keywords() {
    check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
    
    if (!current_user_can("manage_options")) {
        wp_send_json_error(array("message" => "Insufficient permissions"));
    }
    
    $sku = isset($_POST["sku"]) ? sanitize_text_field($_POST["sku"]) : "";
    
    if (empty($sku)) {
        wp_send_json_error(array("message" => "SKU is required"));
    }
    
    // Get keywords from table
    $keywords = $this->get_keywords_from_table($sku);
    
    wp_send_json_success(array(
        "keywords" => $keywords,
        "sku" => $sku,
        "count" => count($keywords)
    ));
}

/**
 * Simple KT Cigar Fix Script
 * Add these methods to your KT_Cigar_Enhanced_Matcher class
 * Or create a separate file and include WordPress
 */

/**
 * Simple method to fix the most common issues
 * Call this from your plugin admin page
 */
public function simple_fix_all_issues() {
    $this->log_debug("=== APPLYING SIMPLE FIXES ===");
    
    $fixes_applied = [];
    $issues_found = [];
    
    // Fix 1: Clear all caches
    delete_transient('kt_cigar_processed_db_products_v2');
    delete_transient('kt_cigar_processed_db_products_v3');
    wp_cache_flush();
    $fixes_applied[] = "Cleared all caches";
    
    // Fix 2: Reinitialize KT_Cigar_Mappings
    if (class_exists('KT_Cigar_Mappings')) {
        KT_Cigar_Mappings::init(true);
        $fixes_applied[] = "Reinitialized KT_Cigar_Mappings";
    } else {
        $issues_found[] = "KT_Cigar_Mappings class not found";
    }
    
    // Fix 3: Check and fix data file
    $data_file_path = WP_CONTENT_DIR . '/cigar-mappings-data.php';
    if (!file_exists($data_file_path)) {
        $issues_found[] = "Data file missing: $data_file_path";
    } else {
        $fixes_applied[] = "Data file exists and is readable";
    }
    
    // Fix 4: Test basic functionality
    if (class_exists('KT_Cigar_Mappings')) {
        try {
            $test_result = KT_Cigar_Mappings::process_supplier_product("高希霸 55周年 2021年限量版 10支 150*57");
            if (!empty($test_result['brand'])) {
                $fixes_applied[] = "Brand extraction working (extracted: {$test_result['brand']})";
            } else {
                $issues_found[] = "Brand extraction not working";
            }
            
            if (!empty($test_result['keywords']) && count($test_result['keywords']) > 2) {
                $fixes_applied[] = "Keyword extraction working (" . count($test_result['keywords']) . " keywords)";
            } else {
                $issues_found[] = "Keyword extraction producing few keywords";
            }
        } catch (Exception $e) {
            $issues_found[] = "KT_Cigar_Mappings error: " . $e->getMessage();
        }
    }
    
    // Fix 5: Check database
    global $wpdb;
    $master_table = $wpdb->prefix . 'master_products';
    if ($wpdb->get_var("SHOW TABLES LIKE '$master_table'") != $master_table) {
        $issues_found[] = "Master products table missing";
    } else {
        $count = $wpdb->get_var("SELECT COUNT(*) FROM $master_table WHERE (product_type = 'cigar' OR product_type = '')");
        $fixes_applied[] = "Database OK: $count products found";
    }
    
    // Fix 6: Preprocess database products
    try {
        $processed_products = $this->preprocess_all_database_products();
        if (!empty($processed_products)) {
            $fixes_applied[] = "Database preprocessing working: " . count($processed_products) . " products";
        } else {
            $issues_found[] = "Database preprocessing returned no products";
        }
    } catch (Exception $e) {
        $issues_found[] = "Database preprocessing error: " . $e->getMessage();
    }
    
    $this->log_debug("FIXES APPLIED: " . implode(", ", $fixes_applied));
    if (!empty($issues_found)) {
        $this->log_debug("ISSUES STILL REMAINING: " . implode(", ", $issues_found));
    }
    
    return [
        'fixes_applied' => $fixes_applied,
        'issues_found' => $issues_found,
        'success' => empty($issues_found)
    ];
}

/**
 * Simple brand extraction test
 */
public function simple_brand_test() {
    $test_cases = [
        "大卫杜夫 温斯顿丘吉尔 2025年限量版 10支 178*48" => "Davidoff",
        "高希霸 55周年 2021年限量版 10支 150*57" => "Cohiba",
        "蒙特 短号保湿盒 蛇年限量 66支 82*27" => "Montecristo",
        "波尔 利昂 西班牙地限 10支 155*42" => "Por Larranaga"
    ];
    
    $results = [];
    
    if (!class_exists('KT_Cigar_Mappings')) {
        return ['error' => 'KT_Cigar_Mappings class not found'];
    }
    
    foreach ($test_cases as $title => $expected) {
        try {
            $result = KT_Cigar_Mappings::process_supplier_product($title);
            $extracted = $result['brand'] ?? null;
            
            $results[] = [
                'title' => $title,
                'expected' => $expected,
                'extracted' => $extracted,
                'success' => !empty($extracted),
                'correct' => (strtolower($extracted ?? '') === strtolower($expected)),
                'keywords_count' => count($result['keywords'] ?? [])
            ];
        } catch (Exception $e) {
            $results[] = [
                'title' => $title,
                'expected' => $expected,
                'extracted' => null,
                'success' => false,
                'correct' => false,
                'error' => $e->getMessage(),
                'keywords_count' => 0
            ];
        }
    }
    
    return $results;
}

/**
 * Emergency keyword extraction fallback
 */
private function emergency_keyword_extraction($title) {
    $keywords = [];
    
    // Always add full title as fallback
    $keywords[] = "FULL:" . strtolower($title);
    
    // Extract Chinese characters (most important for matching)
    if (preg_match_all('/[\x{4e00}-\x{9fa5}]+/u', $title, $matches)) {
        foreach ($matches[0] as $word) {
            if (mb_strlen($word) >= 2) {
                $keywords[] = $word;
                
                // Break down longer Chinese phrases
                if (mb_strlen($word) > 3) {
                    for ($i = 0; $i <= mb_strlen($word) - 2; $i++) {
                        $substring = mb_substr($word, $i, 2);
                        $keywords[] = $substring;
                    }
                }
            }
        }
    }
    
    // Extract all numbers
    if (preg_match_all('/\d+/', $title, $matches)) {
        foreach ($matches[0] as $num) {
            $keywords[] = "NUM:" . $num;
        }
    }
    
    // Extract English words
    if (preg_match_all('/[a-zA-Z]{3,}/', $title, $matches)) {
        foreach ($matches[0] as $word) {
            $keywords[] = strtolower($word);
        }
    }
    
    // Extract brand keywords using simple patterns
    $brand_patterns = [
        '大卫杜夫' => 'davidoff',
        '高希霸' => 'cohiba',
        '蒙特' => 'montecristo',
        '罗密欧' => 'romeo',
        '波尔' => 'por',
        '利昂' => 'larranaga'
    ];
    
    $title_lower = mb_strtolower($title);
    foreach ($brand_patterns as $chinese => $english) {
        if (mb_strpos($title_lower, $chinese) !== false) {
            $keywords[] = "BRAND:" . $english;
            $keywords[] = $english;
        }
    }
    
    return array_unique($keywords);
}

/**
 * Override the main processing method with emergency fallbacks
 */
private function process_supplier_product_with_fallback($supplier_product, $supplier_name) {
    $product_id = $supplier_product["id"] ?? "unknown";
    $product_title = $supplier_product["title"] ?? "Untitled";
    
    // Try normal processing first
    try {
        $result = $this->process_supplier_product($supplier_product, $supplier_name);
        
        // Check if we got meaningful results
        if (!empty($result["matched_terms"]) || $result["match_status"] !== "no_match") {
            return $result;
        }
    } catch (Exception $e) {
        $this->log_debug("Normal processing failed: " . $e->getMessage());
    }
    
    // Emergency fallback processing
    $this->log_debug("Using emergency fallback for: $product_title");
    
    $emergency_keywords = $this->emergency_keyword_extraction($product_title);
    
    // Try to find matches using emergency keywords
    $emergency_result = [
        "product_id" => $product_id,
        "product_title" => $product_title,
        "match_status" => "no_match",
        "best_match" => null,
        "matched_terms" => $emergency_keywords
    ];
    
    // Simple brand-based matching
    global $wpdb;
    $master_table = $wpdb->prefix . 'master_products';
    
    // Look for products with similar brand keywords
    foreach ($emergency_keywords as $keyword) {
        if (strpos($keyword, 'BRAND:') === 0) {
            $brand = str_replace('BRAND:', '', $keyword);
            
            $similar_products = $wpdb->get_results($wpdb->prepare(
                "SELECT sku, product_title FROM $master_table 
                WHERE (product_title LIKE %s OR brand LIKE %s) 
                AND (product_type = 'cigar' OR product_type = '') 
                LIMIT 3",
                '%' . $brand . '%',
                '%' . $brand . '%'
            ));
            
            if ($similar_products) {
                $emergency_result["match_status"] = "possible_match";
                $emergency_result["best_match"] = [
                    "sku" => $similar_products[0]->sku,
                    "title" => $similar_products[0]->product_title,
                    "score" => 35 // Low score for emergency match
                ];
                break;
            }
        }
    }
    
    return $emergency_result;
}

/**
 * Simple AJAX handler for the fix
 */
public function ajax_simple_fix() {
    check_ajax_referer("kt-cigar-matcher-nonce", "nonce");
    
    if (!current_user_can("manage_options")) {
        wp_send_json_error(["message" => "Insufficient permissions"]);
    }
    
    $fix_results = $this->simple_fix_all_issues();
    $brand_test_results = $this->simple_brand_test();
    
    wp_send_json_success([
        "fixes" => $fix_results,
        "brand_tests" => $brand_test_results,
        "message" => $fix_results['success'] ? "All issues fixed!" : "Some issues remain"
    ]);
}

// Register the AJAX handler (add to constructor)
// add_action("wp_ajax_kt_cigar_matcher_simple_fix", array($this, "ajax_simple_fix"));





}


// Initialize the plugin
$kt_cigar_enhanced_matcher = new KT_Cigar_Enhanced_Matcher();
