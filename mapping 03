
/**
 * KT Cigar Mappings - Advanced Brand and Series Recognition
 * Version: 9.3 - Enhanced for better integration with other components
 */

// Exit if accessed directly
if (!defined("ABSPATH")) {
    exit;
}

// Add this before your KT_Cigar_Mappings class
class KT_Cigar_Debug {
    public static function log($message) {
        // Check if debugging is enabled
        if (!defined('KT_DEBUG') || !KT_DEBUG) {
            return;
        }
        
        $log_file = WP_CONTENT_DIR . '/cigar-debug.log';
        $timestamp = date('Y-m-d H:i:s');
        
        // Prepare message with timestamp
        $log_message = "$timestamp - $message\n";
        
        // Append to log file
        file_put_contents($log_file, $log_message, FILE_APPEND);
    }
}

class KT_Cigar_Mappings {
	    private static $logged_messages = []; // Add this line

	
	
    // Static properties
    private static $initialized = false;
    private static $data_file = null;
    
    /**
     * Initialize the class with data file
     * 
     * @param bool $force Force reinitialization
     */
  
/**
 * Fix the data file loading in KT_Cigar_Mappings::init()
 * The current code might be failing silently
 */

// In KT_Cigar_Mappings class, replace the init() method:

public static function init($force = false) {
    if (self::$initialized && !$force) {
        return;
    }
    
    // Set the data file path
    $data_file_path = WP_CONTENT_DIR . '/cigar-mappings-data.php';
    
    KT_Cigar_Debug::log("Attempting to load data file: " . $data_file_path);
    
    // Load data file if it exists
    if (file_exists($data_file_path)) {
        try {
            self::$data_file = include $data_file_path;
            
            if (!is_array(self::$data_file)) {
                KT_Cigar_Debug::log("ERROR: Data file did not return an array");
                self::$data_file = array();
            } else {
                KT_Cigar_Debug::log("SUCCESS: Data file loaded with " . count(self::$data_file) . " top-level keys");
                
                // Debug: Check if brands section exists
                if (isset(self::$data_file['brands'])) {
                    $cuban_count = count(self::$data_file['brands']['cuban'] ?? []);
                    $non_cuban_count = count(self::$data_file['brands']['non_cuban'] ?? []);
                    KT_Cigar_Debug::log("Brands loaded: Cuban=$cuban_count, Non-Cuban=$non_cuban_count");
                } else {
                    KT_Cigar_Debug::log("ERROR: No 'brands' section in data file");
                }
                
                // Debug: Check series section
                if (isset(self::$data_file['series'])) {
                    KT_Cigar_Debug::log("Series data loaded for " . count(self::$data_file['series']) . " brands");
                } else {
                    KT_Cigar_Debug::log("ERROR: No 'series' section in data file");
                }
            }
        } catch (Exception $e) {
            KT_Cigar_Debug::log("ERROR loading data file: " . $e->getMessage());
            self::$data_file = array();
        }
    } else {
        KT_Cigar_Debug::log("ERROR: Data file not found: " . $data_file_path);
        self::$data_file = array();
        
        // Create default data structure
        self::$data_file = array(
            'brands' => array(
                'cuban' => array(),
                'non_cuban' => array()
            ),
            'series' => array(),
            'sizes' => array(),
            'vitola_mappings' => array(),
            'special_editions' => array(),
            'limited_editions_by_year' => array(),
            'packaging' => array(),
            'brand_aliases' => array(),
            'zodiac_years' => array()
        );
    }
    
    self::$initialized = true;
    KT_Cigar_Debug::log("KT_Cigar_Mappings initialization complete. Initialized: " . (self::$initialized ? 'YES' : 'NO'));
}
    
    /**
     * Process a supplier product title to extract relevant information
     * 
     * @param string $title Product title
     * @param string $dimensions Dimensions string (optional)
     * @param string $description Product description (optional)
     * @return array Processed product data
     */
    public static function process_supplier_product($title, $dimensions = "", $description = "") {
        // Ensure class is initialized
        self::init();
        
        // Normalize title and store original
        $original_title = trim($title);
        $normalized_title = mb_strtolower(trim($title));
        
        // Initialize result array
        $result = array(
            "title" => $original_title,
            "normalized_title" => $normalized_title,
            "brand" => null,
            "model" => null,
            "vitola" => null,
            "special_edition" => null,
            "year" => null,
            "count" => null,
            "dimension_info" => array(
                "ring_gauge" => null,
                "length" => null,
                "format" => null
            ),
            "packaging" => null,
            "keywords" => array(),
            "filtered_title" => $normalized_title
        );
        
        KT_Cigar_Debug::log("Processing supplier title: " . $original_title);
        
        // Step 1: First identify if this is a Chinese title - a key factor for processing logic
        $has_chinese_chars = preg_match('/[\x{4e00}-\x{9fa5}]/u', $title);
        KT_Cigar_Debug::log("Title contains Chinese characters: " . ($has_chinese_chars ? "Yes" : "No"));
        
       // Step 2: Extract brand using data file mappings and aliases
        // First check brand aliases for any language
        if (!empty(self::$data_file['brand_aliases'])) {
            foreach (self::$data_file['brand_aliases'] as $alias => $english_brand) {
                if (mb_stripos($normalized_title, mb_strtolower($alias)) !== false) {
                    $result["brand"] = $english_brand;
                    KT_Cigar_Debug::log("Extracted brand from alias: " . $alias . " -> " . $english_brand);
                    break;
                }
            }
        }

        // If no brand found via aliases, check brand variations
        if (empty($result["brand"])) {
            foreach (['cuban', 'non_cuban'] as $section) {
                if (isset(self::$data_file['brands'][$section])) {
                    foreach (self::$data_file['brands'][$section] as $brand => $variations) {
                        // Check main brand name first
                        if (mb_stripos($normalized_title, mb_strtolower($brand)) !== false) {
                            $result["brand"] = $brand;
                            KT_Cigar_Debug::log("Extracted brand from main name: " . $brand);
                            break 2;
                        }
                        
                        // Check each variation
                        foreach ($variations as $variation) {
                            if (mb_stripos($normalized_title, mb_strtolower($variation)) !== false) {
                                $result["brand"] = $brand;
                                KT_Cigar_Debug::log("Extracted brand from variation: " . $variation . " -> " . $brand);
                                break 3;
                            }
                        }
                    }
                }
            }
        
      }
        
        // If no brand found via aliases, check brand variations (for ALL titles)
        if (empty($result["brand"])) {
            if (isset(self::$data_file['brands']['cuban'])) {
                foreach (self::$data_file['brands']['cuban'] as $brand => $variations) {
                    if (mb_stripos($normalized_title, mb_strtolower($brand)) !== false) {
                        $result["brand"] = $brand;
                        KT_Cigar_Debug::log("Extracted brand: " . $brand);
                        break;
                    }
                    
                    foreach ($variations as $variation) {
                        if (mb_stripos($normalized_title, mb_strtolower($variation)) !== false) {
                            $result["brand"] = $brand;
                            KT_Cigar_Debug::log("Extracted brand from variation: " . $brand);
                            break 2;
                        }
                    }
                }
            }
            // If no Cuban brand found, try non-Cuban
            if (empty($result["brand"]) && isset(self::$data_file['brands']['non_cuban'])) {
                foreach (self::$data_file['brands']['non_cuban'] as $brand => $variations) {
                    if (mb_stripos($normalized_title, mb_strtolower($brand)) !== false) {
                        $result["brand"] = $brand;
                        KT_Cigar_Debug::log("Extracted non-Cuban brand: " . $brand);
                        break;
                    }
                    
                    foreach ($variations as $variation) {
                        if (mb_stripos($normalized_title, mb_strtolower($variation)) !== false) {
                            $result["brand"] = $brand;
                            KT_Cigar_Debug::log("Extracted non-Cuban brand from variation: " . $brand);
                            break 2;
                        }
                    }
                }
            }
        }
        // Step 3: Extract dimensions - handle Chinese pattern "数字*数字" or bracketed formats
        if (!empty($dimensions)) {
            // Parse provided dimensions
            $dimension_parts = explode("/", $dimensions);
            if (count($dimension_parts) == 2) {
                $result["dimension_info"]["ring_gauge"] = trim($dimension_parts[0]);
                $result["dimension_info"]["length"] = trim($dimension_parts[1]);
                $result["dimension_info"]["format"] = trim($dimensions);
                KT_Cigar_Debug::log("Extracted dimensions from parameter: " . $dimensions);
            }
        } else {
            // Try to extract from title
            // Common patterns: 140*52, 140×52, [140×52], etc.
            if (preg_match('/(\d+)\s*[xX×*\/]\s*(\d+)/', $normalized_title, $matches)) {
                $first_num = intval($matches[1]);
                $second_num = intval($matches[2]);
                
                // Determine which is ring gauge and which is length
                if ($first_num > $second_num && $second_num >= 20 && $second_num <= 70) {
                    $result["dimension_info"]["length"] = $first_num;
                    $result["dimension_info"]["ring_gauge"] = $second_num;
                    $result["dimension_info"]["format"] = $second_num . "/" . $first_num;
                } else if ($second_num > $first_num && $first_num >= 20 && $first_num <= 70) {
                    $result["dimension_info"]["length"] = $second_num;
                    $result["dimension_info"]["ring_gauge"] = $first_num;
                    $result["dimension_info"]["format"] = $first_num . "/" . $second_num;
                } else {
                    // Default assumption (most common format: length*ring)
                    $result["dimension_info"]["length"] = $first_num;
                    $result["dimension_info"]["ring_gauge"] = $second_num;
                    $result["dimension_info"]["format"] = $second_num . "/" . $first_num;
                }
                
                KT_Cigar_Debug::log("Extracted dimensions from title: " . 
                                $result["dimension_info"]["ring_gauge"] . "/" . 
                                $result["dimension_info"]["length"]);
            }
            
            // Try more specific dimension extraction patterns from data file
            if (isset(self::$data_file['dimension_patterns']) && 
                (empty($result["dimension_info"]["ring_gauge"]) || empty($result["dimension_info"]["length"]))) {
                
                // Try to extract ring gauge
                if (empty($result["dimension_info"]["ring_gauge"]) && 
                    isset(self::$data_file['dimension_patterns']['ring_gauge'])) {
                    
                    foreach (self::$data_file['dimension_patterns']['ring_gauge'] as $pattern) {
                        if (preg_match($pattern, $normalized_title, $matches)) {
                            $result["dimension_info"]["ring_gauge"] = $matches[1];
                            KT_Cigar_Debug::log("Extracted ring gauge from pattern: " . $result["dimension_info"]["ring_gauge"]);
                            break;
                        }
                    }
                }
                
                // Try to extract length
                if (empty($result["dimension_info"]["length"]) && 
                    isset(self::$data_file['dimension_patterns']['length'])) {
                    
                    foreach (self::$data_file['dimension_patterns']['length'] as $pattern) {
                        if (preg_match($pattern, $normalized_title, $matches)) {
                            $result["dimension_info"]["length"] = $matches[1];
                            KT_Cigar_Debug::log("Extracted length from pattern: " . $result["dimension_info"]["length"]);
                            break;
                        }
                    }
                }
                
                // Create format if both values are now available
                if (!empty($result["dimension_info"]["ring_gauge"]) && !empty($result["dimension_info"]["length"])) {
                    $result["dimension_info"]["format"] = $result["dimension_info"]["ring_gauge"] . "/" . 
                                                         $result["dimension_info"]["length"];
                }
            }
        }
        
        // Step 4: Extract count (typically followed by "支" in Chinese titles)
        if (preg_match('/(\d+)\s*(?:支|pcs|个|count|ct|-count)/ui', $normalized_title, $count_matches)) {
            $result["count"] = $count_matches[1];
            KT_Cigar_Debug::log("Extracted count: " . $result["count"]);
        } else if (preg_match('/box\s+of\s+(\d+)/i', $normalized_title, $box_matches)) {
            $result["count"] = $box_matches[1];
            KT_Cigar_Debug::log("Extracted count from 'box of': " . $result["count"]);
        }
        
        // Step 5: Extract year (particularly for Chinese limited editions which often include year)
        if (preg_match('/(\d{4})(?:年|限量版?|LE|Limited Edition)?/iu', $normalized_title, $year_matches)) {
            $year = intval($year_matches[1]);
            $current_year = intval(date('Y'));
            
            // Validate year is reasonable
            if ($year >= 1950 && $year <= $current_year + 1) {  // Allow next year for pre-releases
                $result["year"] = $year_matches[1];
                KT_Cigar_Debug::log("Extracted year: " . $result["year"]);
                
                // If we have a limited edition year, also set special_edition
                if (isset(self::$data_file['limited_editions_by_year']) && 
                    isset(self::$data_file['limited_editions_by_year'][$result["year"]])) {
                    
                    if (empty($result["special_edition"])) {
                        $result["special_edition"] = $result["year"] . " Limited Edition";
                    } else {
                        $result["special_edition"] .= " (" . $result["year"] . ")";
                    }
                    
                    KT_Cigar_Debug::log("Added limited edition from year: " . $result["special_edition"]);
                }
            }
        }
        
        // Step 6: Extract series/model if brand was identified
        if (!empty($result["brand"]) && isset(self::$data_file['series'][$result["brand"]])) {
            foreach (self::$data_file['series'][$result["brand"]] as $series => $variations) {
                if (mb_stripos($normalized_title, mb_strtolower($series)) !== false) {
                    $result["model"] = $series;
                    KT_Cigar_Debug::log("Extracted series: " . $series);
                    break;
                }
                
                foreach ($variations as $variation) {
                    if (mb_stripos($normalized_title, mb_strtolower($variation)) !== false) {
                        $result["model"] = $series;
                        KT_Cigar_Debug::log("Extracted series from variation: " . $series);
                        break 2;
                    }
                }
            }
        }
        
        // Step 7: Extract special edition info - particularly important for Chinese titles
        // Common patterns: 限量版, 纪念版, 周年, etc.
        $special_edition_patterns = [
            '限量版', '纪念版', '周年', '特别版', '特制版', 
            'limited edition', 'edicion limitada', 'anniversary', 
            'special', 'regional', 'reserva'
        ];
        
        foreach ($special_edition_patterns as $pattern) {
            if (mb_stripos($normalized_title, $pattern) !== false) {
                // Extract the surrounding context for better special edition info
                $special_edition = '';
                
                if ($result["year"]) {
                    $special_edition = $result["year"] . " ";
                }
                
                $special_edition .= "Limited Edition";
                
                // Add regional info if found
                if (mb_stripos($normalized_title, '地区') !== false || 
                    mb_stripos($normalized_title, 'regional') !== false) {
                    $special_edition .= " Regional Edition";
                }
                
                $result["special_edition"] = $special_edition;
                KT_Cigar_Debug::log("Extracted special edition: " . $special_edition);
                break;
            }
        }
        
        // Check against data file special editions if none found yet
        if (empty($result["special_edition"]) && isset(self::$data_file['special_editions'])) {
            foreach (self::$data_file['special_editions'] as $edition => $variations) {
                if (mb_stripos($normalized_title, mb_strtolower($edition)) !== false) {
                    $result["special_edition"] = $edition;
                    KT_Cigar_Debug::log("Extracted special edition from data file: " . $edition);
                    break;
                }
                
                foreach ($variations as $variation) {
                    if (mb_stripos($normalized_title, mb_strtolower($variation)) !== false) {
                        $result["special_edition"] = $edition;
                        KT_Cigar_Debug::log("Extracted special edition from data file variation: " . $edition);
                        break 2;
                    }
                }
            }
        }
        
        // Step 8: Handle Chinese zodiac years which are common for limited editions
        if (isset(self::$data_file['zodiac_years'])) {
            foreach (self::$data_file['zodiac_years'] as $zodiac => $variations) {
                foreach ($variations as $variation) {
                    if (mb_stripos($normalized_title, $variation) !== false) {
                        $zodiac_special_edition = "Year of the " . ucfirst($zodiac);
                        
                        if (empty($result["special_edition"])) {
                            $result["special_edition"] = $zodiac_special_edition;
                        } else {
                            $result["special_edition"] .= " - " . $zodiac_special_edition;
                        }
                        
                        KT_Cigar_Debug::log("Extracted zodiac year: " . $zodiac_special_edition);
                        break 2;
                    }
                }
            }
        }
        
        // Step 9: Extract specific vitola/size (this should be enhanced for Chinese vitolas)
        $vitola_mapping = [
            // Common vitolas in Chinese and English
            '罗伯图' => 'Robusto',
            '托罗' => 'Toro',
            '公牛' => 'Toro',
            '大公牛' => 'Gran Toro',
            '鱼雷' => 'Torpedo',
            '丘吉尔' => 'Churchill',
            '长矛' => 'Lancero',
            '皇冠' => 'Corona',
            '小皇冠' => 'Petit Corona',
            '短号' => 'Short',
            '宽短号' => 'Wide Short'
        ];
        
        foreach ($vitola_mapping as $chinese => $english) {
            if (mb_stripos($normalized_title, $chinese) !== false) {
                $result["vitola"] = $english;
                KT_Cigar_Debug::log("Extracted vitola: " . $english);
                break;
            }
        }
        
        // If no specific vitola found, try data file matching
        if (empty($result["vitola"]) && isset(self::$data_file['vitola_mappings'])) {
            foreach (self::$data_file['vitola_mappings'] as $vitola => $variations) {
                if (mb_stripos($normalized_title, mb_strtolower($vitola)) !== false) {
                    $result["vitola"] = $vitola;
                    KT_Cigar_Debug::log("Extracted vitola from data file: " . $vitola);
                    break;
                }
                
                foreach ($variations as $variation) {
                    if (mb_stripos($normalized_title, mb_strtolower($variation)) !== false) {
                        $result["vitola"] = $vitola;
                        KT_Cigar_Debug::log("Extracted vitola from data file variation: " . $vitola);
                        break 2;
                    }
                }
            }
        }
        
        // If still no vitola, try standard sizes
        if (empty($result["vitola"]) && isset(self::$data_file['sizes'])) {
            foreach (self::$data_file['sizes'] as $vitola => $variations) {
                if (mb_stripos($normalized_title, mb_strtolower($vitola)) !== false) {
                    $result["vitola"] = $vitola;
                    KT_Cigar_Debug::log("Extracted vitola from sizes: " . $vitola);
                    break;
                }
                
                foreach ($variations as $variation) {
                    if (mb_stripos($normalized_title, mb_strtolower($variation)) !== false) {
                        $result["vitola"] = $vitola;
                        KT_Cigar_Debug::log("Extracted vitola from sizes variation: " . $vitola);
                        break 2;
                    }
                }
            }
        }
        
        // Step 10: Extract packaging if available in data file
        if (isset(self::$data_file['packaging'])) {
            foreach (self::$data_file['packaging'] as $packaging => $variations) {
                foreach ($variations as $variation) {
                    if (mb_stripos($normalized_title, mb_strtolower($variation)) !== false) {
                        $result["packaging"] = $packaging;
                        KT_Cigar_Debug::log("Extracted packaging: " . $packaging);
                        break 2;
                    }
                }
            }
        }
        
        // Step 11: Generate list of categorized keywords
        $keywords = [];
        
        // Add tagged keywords for extracted metadata
        if ($result["brand"]) {
            $keywords[] = "BRAND:" . $result["brand"];
        }
        
        if ($result["model"]) {
            $keywords[] = "SERIES:" . $result["model"];
        }
        
        if ($result["vitola"]) {
            $keywords[] = "VITOLA:" . $result["vitola"];
        }
        
        if ($result["special_edition"]) {
            $keywords[] = "SPECIAL:" . $result["special_edition"];
        }
        
        if ($result["year"]) {
            $keywords[] = "YEAR:" . $result["year"];
        }
        
        if ($result["count"]) {
            $keywords[] = "COUNT:" . $result["count"];
        }
        
        if (!empty($result["dimension_info"]["format"])) {
            $keywords[] = "DIM:" . $result["dimension_info"]["format"];
        } else if (!empty($result["dimension_info"]["ring_gauge"]) || !empty($result["dimension_info"]["length"])) {
            $dim_str = (!empty($result["dimension_info"]["ring_gauge"]) ? $result["dimension_info"]["ring_gauge"] : "?") . "/" .
                      (!empty($result["dimension_info"]["length"]) ? $result["dimension_info"]["length"] : "?");
            $keywords[] = "DIM:" . $dim_str;
        }
        
        if ($result["packaging"]) {
            $keywords[] = "PACK:" . $result["packaging"];
        }
       // Extract and add additional keywords using intelligent tokenization
        // This is crucial for making the Chinese titles work well
        $remaining_title = $normalized_title;
        
        // Remove the already identified parts
        if ($result["brand"]) {
            $brand_lower = mb_strtolower($result["brand"]);
            $remaining_title = str_replace($brand_lower, '', $remaining_title);
            
            // Remove brand variations from data file
            if (isset(self::$data_file['brands'])) {
                foreach (['cuban', 'non_cuban'] as $section) {
                    if (isset(self::$data_file['brands'][$section][$result["brand"]])) {
                        foreach (self::$data_file['brands'][$section][$result["brand"]] as $variation) {
                            $variation_lower = mb_strtolower($variation);
                            $remaining_title = str_replace($variation_lower, '', $remaining_title);
                        }
                        break;
                    }
                }
            }
            
            // Also check brand aliases
            if (isset(self::$data_file['brand_aliases'])) {
                foreach (self::$data_file['brand_aliases'] as $alias => $brand_name) {
                    if ($brand_name == $result["brand"]) {
                        $alias_lower = mb_strtolower($alias);
                        $remaining_title = str_replace($alias_lower, '', $remaining_title);
                    }
                }
            }
            // Try to remove more brand variations from data file
            if (isset(self::$data_file['brands'])) {
                $found_brand = false;
                
                foreach (self::$data_file['brands'] as $origin => $brands) {
                    if (isset($brands[$result["brand"]])) {
                        foreach ($brands[$result["brand"]] as $variation) {
                            $variation_lower = mb_strtolower($variation);
                            $remaining_title = str_replace($variation_lower, '', $remaining_title);
                        }
                        $found_brand = true;
                        break;
                    }
                }
                
                // If brand not found directly, check aliases
                if (!$found_brand && isset(self::$data_file['brand_aliases'])) {
                    foreach (self::$data_file['brand_aliases'] as $alias => $brand_name) {
                        if ($brand_name == $result["brand"]) {
                            $alias_lower = mb_strtolower($alias);
                            $remaining_title = str_replace($alias_lower, '', $remaining_title);
                        }
                    }
                }
            }
        }
        
        // Remove dimensions from remaining title
        if (!empty($result["dimension_info"]["format"])) {
            $remaining_title = str_replace($result["dimension_info"]["format"], '', $remaining_title);
        } else if (preg_match('/(\d+)\s*[xX×*\/]\s*(\d+)/', $normalized_title, $matches)) {
            $remaining_title = str_replace($matches[0], '', $remaining_title);
        }
        
        // Clean remaining title
        $remaining_title = preg_replace('/\s+/', ' ', $remaining_title);
        $remaining_title = trim($remaining_title);
        
        // Extract Chinese word fragments (typically 2-3 character meaningful phrases)
        if ($has_chinese_chars) {
            preg_match_all('/[\x{4e00}-\x{9fa5}]{2,5}/u', $remaining_title, $chinese_words);
            foreach ($chinese_words[0] as $word) {
                if (mb_strlen($word) >= 2) {
                    $keywords[] = $word;
                }
            }
        }
        
        // Extract English word fragments
        preg_match_all('/[a-zA-Z]{3,}/u', $remaining_title, $english_words);
        foreach ($english_words[0] as $word) {
            if (mb_strlen($word) >= 3 && !in_array(mb_strtolower($word), ['the', 'and', 'for', 'with'])) {
                $keywords[] = $word;
            }
        }
        
        // Filter out common filter words
        $filtered_keywords = array();
        $common_filter_words = isset(self::$data_file['ignored_terms']) ? 
            self::$data_file['ignored_terms'] : 
            array(
                "cigar", "cigars", "original", "genuine", "authentic", "box",
                "set", "new", "cube", "盒", "盒装", "box", "装", "只", "支"
            );
        
        foreach ($keywords as $keyword) {
            // Skip already categorized keywords (with tags)
            if (strpos($keyword, ':') !== false) {
                $filtered_keywords[] = $keyword;
                continue;
            }
            
            // Check if this is a common filter word
            $is_common = false;
            foreach ($common_filter_words as $filter_word) {
                if (mb_strtolower($keyword) === mb_strtolower($filter_word)) {
                    $is_common = true;
                    break;
                }
            }
            
            if (!$is_common) {
                $filtered_keywords[] = $keyword;
            }
        }
        
        // Add full title as reference
        $filtered_keywords[] = "FULL:" . $normalized_title;
        
        // De-duplicate keywords
        $result["keywords"] = array_values(array_unique($filtered_keywords));
        
        return $result;
    }
    
    /**
     * Process an internal product for matching and extraction
     * 
     * @param string $sku Product SKU
     * @param string $title Product title
     * @param string $dimensions Dimensions string
     * @return array Processed product data
     */
    public static function process_internal_product($sku, $title, $dimensions = "") {
        // Initialize with supplier processing logic
        $result = self::process_supplier_product($title, $dimensions);
        
        // Add SKU to result
        $result["sku"] = $sku;
        
        // Add any additional processing specific to internal products
        // For internal products, leverage any additional database fields that might be available
        
        return $result;
    }
    
    /**
     * Categorize a keyword based on data file
     * 
     * @param string $keyword The keyword to categorize
     * @param array $product_data Product context data (optional)
     * @return string Category name (brand, model, vitola, etc.)
     */
    public static function categorize_keyword($keyword, $product_data = array()) {
        // Make sure we're initialized
        self::init();
        
        // Check if already tagged
        if (preg_match('/^([A-Z_]+):(.+)$/i', $keyword, $matches)) {
            $tag = strtoupper($matches[1]);
            
            switch ($tag) {
                case 'BRAND': return 'brand';
                case 'SERIES': return 'model';
                case 'VITOLA': return 'vitola';
               case 'SPECIAL': return 'special_edition';
                case 'YEAR': return 'year';
                case 'COUNT': return 'count';
                case 'DIM': return 'dimensions';
                case 'PACK': return 'packaging';
                default: return 'generic';
            }
        }
        
        $keyword_lower = mb_strtolower(trim($keyword));
        $product_brand = !empty($product_data["brand"]) ? mb_strtolower($product_data["brand"]) : '';
        
        // Check for clear dimension patterns
        if (preg_match('/(\d+)\s*[xX×*\/]\s*(\d+)/', $keyword_lower) || 
            preg_match('/^(\d+)\/(\d+)$/', $keyword_lower)) {
            return 'dimensions';
        }
        
        // Check for year pattern
        if (preg_match('/^(19|20)\d{2}$/', $keyword_lower)) {
            return 'year';
        }
        
        // Check for count patterns
        if (preg_match('/^(\d+)-Count(?:\s+box)?$/i', $keyword_lower) || 
            preg_match('/^Count:\s+(\d+)$/i', $keyword_lower) ||
            preg_match('/^(\d+)支\/盒$/', $keyword_lower) ||
            preg_match('/^(\d+)支装$/', $keyword_lower) ||
            preg_match('/^(\d+)-Count$/', $keyword_lower) ||
            preg_match('/^Box\s+of\s+(\d+)$/i', $keyword_lower)) {
            return 'count';
        }
        
        // Check brand against data file
        if (isset(self::$data_file['brands'])) {
            foreach (self::$data_file['brands'] as $origin => $brands) {
                foreach ($brands as $brand => $variations) {
                    if (mb_strtolower($brand) === $keyword_lower) {
                        return 'brand';
                    }
                    
                    foreach ($variations as $variation) {
                        if (mb_strtolower($variation) === $keyword_lower) {
                            return 'brand';
                        }
                    }
                }
            }
        }
        
        // Check brand aliases
        if (isset(self::$data_file['brand_aliases'])) {
            foreach (self::$data_file['brand_aliases'] as $alias => $brand_name) {
                if (mb_strtolower($alias) === $keyword_lower) {
                    return 'brand';
                }
            }
        }
        
        // Check series for the product's brand
        if (!empty($product_brand) && isset(self::$data_file['series'][$product_brand])) {
            foreach (self::$data_file['series'][$product_brand] as $series => $variations) {
                if (mb_strtolower($series) === $keyword_lower) {
                    return 'model';
                }
                
                foreach ($variations as $variation) {
                    if (mb_strtolower($variation) === $keyword_lower) {
                        return 'model';
                    }
                }
            }
        }
        
        // Check vitola/size
        if (isset(self::$data_file['vitola_mappings'])) {
            foreach (self::$data_file['vitola_mappings'] as $vitola => $variations) {
                if (mb_strtolower($vitola) === $keyword_lower) {
                    return 'vitola';
                }
                
                foreach ($variations as $variation) {
                    if (mb_strtolower($variation) === $keyword_lower) {
                        return 'vitola';
                    }
                }
            }
        }
        
        // Check standard sizes
        if (isset(self::$data_file['sizes'])) {
            foreach (self::$data_file['sizes'] as $size => $variations) {
                if (mb_strtolower($size) === $keyword_lower) {
                    return 'vitola';
                }
                
                foreach ($variations as $variation) {
                    if (mb_strtolower($variation) === $keyword_lower) {
                        return 'vitola';
                    }
                }
            }
        }
        
        // Check special editions
        if (isset(self::$data_file['special_editions'])) {
            foreach (self::$data_file['special_editions'] as $edition => $variations) {
                if (mb_strtolower($edition) === $keyword_lower) {
                    return 'special_edition';
                }
                
                foreach ($variations as $variation) {
                    if (mb_strtolower($variation) === $keyword_lower) {
                        return 'special_edition';
                    }
                }
            }
        }
        
        // Check regional editions
        if (isset(self::$data_file['regional_editions'])) {
            foreach (self::$data_file['regional_editions'] as $region => $variations) {
                if (mb_strtolower($region) === $keyword_lower) {
                    return 'special_edition';
                }
                
                foreach ($variations as $variation) {
                    if (mb_strtolower($variation) === $keyword_lower) {
                        return 'special_edition';
                    }
                }
            }
        }
        
        // Check zodiac years
        if (isset(self::$data_file['zodiac_years'])) {
            foreach (self::$data_file['zodiac_years'] as $zodiac => $variations) {
                foreach ($variations as $variation) {
                    if (mb_strtolower($variation) === $keyword_lower) {
                        return 'special_edition';
                    }
                }
            }
        }
        
        // Check packaging
        if (isset(self::$data_file['packaging'])) {
            foreach (self::$data_file['packaging'] as $package => $variations) {
                if (mb_strtolower($package) === $keyword_lower) {
                    return 'packaging';
                }
                
                foreach ($variations as $variation) {
                    if (mb_strtolower($variation) === $keyword_lower) {
                        return 'packaging';
                    }
                }
            }
        }
        
        // Check for numeric count values
        if (is_numeric($keyword) && intval($keyword) > 0 && intval($keyword) <= 50) {
            return 'count';
        }
        
        // Default to generic if no match found
        return 'generic';
    }
    
    /**
     * Determine if a keyword is a brand or brand variation from the data file
     * 
     * @param string $keyword The keyword to check
     * @return bool True if keyword is a brand or brand variation
     */
    public static function is_brand($keyword) {
        // Make sure we're initialized
        self::init();
        
        $keyword_lower = mb_strtolower(trim($keyword));
        
        // Check against brands in data file
        if (isset(self::$data_file['brands'])) {
            foreach (self::$data_file['brands'] as $origin => $brands) {
                foreach ($brands as $brand => $variations) {
                    if (mb_strtolower($brand) === $keyword_lower) {
                        return true;
                    }
                    
                    foreach ($variations as $variation) {
                        if (mb_strtolower($variation) === $keyword_lower) {
                            return true;
                        }
                    }
                }
            }
        }
        
        // Check against brand aliases
        if (isset(self::$data_file['brand_aliases'])) {
            foreach (self::$data_file['brand_aliases'] as $alias => $brand_name) {
                if (mb_strtolower($alias) === $keyword_lower) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Determine if two brands are the same or aliases of each other
     * 
     * @param string $brand1 First brand name
     * @param string $brand2 Second brand name
     * @return bool True if brands are the same or aliases
     */
    public static function is_same_brand($brand1, $brand2) {
        // Make sure we're initialized
        self::init();
        
        if (empty($brand1) || empty($brand2)) {
            return false;
        }
        
        $brand1_lower = mb_strtolower(trim($brand1));
        $brand2_lower = mb_strtolower(trim($brand2));
        
        // Check direct match
        if ($brand1_lower === $brand2_lower) {
            return true;
        }
        
        // Check if one is a variation of the other
        if (isset(self::$data_file['brands'])) {
            foreach (self::$data_file['brands'] as $origin => $brands) {
                foreach ($brands as $brand => $variations) {
                    $brand_lower = mb_strtolower($brand);
                    
                    // Check if brand1 is the main brand and brand2 is a variation
                    if ($brand_lower === $brand1_lower) {
                        foreach ($variations as $variation) {
                            if (mb_strtolower($variation) === $brand2_lower) {
                                return true;
                            }
                        }
                    }
                    
                    // Check if brand2 is the main brand and brand1 is a variation
                    if ($brand_lower === $brand2_lower) {
                        foreach ($variations as $variation) {
                            if (mb_strtolower($variation) === $brand1_lower) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        
        // Check brand aliases
        if (isset(self::$data_file['brand_aliases'])) {
            // Check if brand1 is an alias for brand2
            foreach (self::$data_file['brand_aliases'] as $alias => $brand_name) {
                if (mb_strtolower($alias) === $brand1_lower && mb_strtolower($brand_name) === $brand2_lower) {
                    return true;
                }
            }
            
            // Check if brand2 is an alias for brand1
            foreach (self::$data_file['brand_aliases'] as $alias => $brand_name) {
                if (mb_strtolower($alias) === $brand2_lower && mb_strtolower($brand_name) === $brand1_lower) {
                    return true;
                }
            }
            
            // Check if both are aliases for the same brand
            $brand1_aliased = null;
            $brand2_aliased = null;
            
            foreach (self::$data_file['brand_aliases'] as $alias => $brand_name) {
                if (mb_strtolower($alias) === $brand1_lower) {
                    $brand1_aliased = mb_strtolower($brand_name);
                }
                if (mb_strtolower($alias) === $brand2_lower) {
                    $brand2_aliased = mb_strtolower($brand_name);
                }
            }
            
            if ($brand1_aliased && $brand2_aliased && $brand1_aliased === $brand2_aliased) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Find the best match for a supplier product among database products
     * 
     * @param array $supplier_product Processed supplier product
     * @param array $db_products Array of database products
     * @param int $max_results Maximum number of results to return
     * @return array Matching results with scores
     */
    public static function find_best_matches($supplier_product, $db_products, $max_results = 5) {
        // Make sure we're initialized
        self::init();
        
        if (empty($supplier_product) || empty($db_products)) {
            return array();
        }
        
        $matches = array();
        
        // Get supplier product properties
        $supplier_brand = !empty($supplier_product["brand"]) ? $supplier_product["brand"] : null;
        $supplier_model = !empty($supplier_product["model"]) ? $supplier_product["model"] : null;
        $supplier_vitola = !empty($supplier_product["vitola"]) ? $supplier_product["vitola"] : null;
        $supplier_special = !empty($supplier_product["special_edition"]) ? $supplier_product["special_edition"] : null;
        $supplier_year = !empty($supplier_product["year"]) ? $supplier_product["year"] : null;
        $supplier_ring = !empty($supplier_product["dimension_info"]["ring_gauge"]) ? $supplier_product["dimension_info"]["ring_gauge"] : null;
        $supplier_length = !empty($supplier_product["dimension_info"]["length"]) ? $supplier_product["dimension_info"]["length"] : null;
        $supplier_keywords = !empty($supplier_product["keywords"]) ? $supplier_product["keywords"] : array();
        
        // Loop through database products to find matches
        foreach ($db_products as $db_product) {
            // Get database product properties
            $db_brand = !empty($db_product["brand"]) ? $db_product["brand"] : null;
            $db_model = !empty($db_product["model"]) ? $db_product["model"] : null;
            $db_vitola = !empty($db_product["vitola"]) ? $db_product["vitola"] : null;
            $db_special = !empty($db_product["special_edition"]) ? $db_product["special_edition"] : null;
            $db_year = !empty($db_product["year"]) ? $db_product["year"] : null;
            $db_ring = !empty($db_product["dimension_info"]["ring_gauge"]) ? $db_product["dimension_info"]["ring_gauge"] : null;
            $db_length = !empty($db_product["dimension_info"]["length"]) ? $db_product["dimension_info"]["length"] : null;
            $db_keywords = !empty($db_product["keywords"]) ? $db_product["keywords"] : array();
            
            // Skip if brands don't match
            if ($supplier_brand && $db_brand && !self::is_same_brand($supplier_brand, $db_brand)) {
                continue;
            }
            
            // Calculate match score
            $score = 0;
            $matched_terms = array();
            
            // Brand match (very important)
            if ($supplier_brand && $db_brand) {
                if (mb_strtolower($supplier_brand) === mb_strtolower($db_brand)) {
                    $score += 40;
                    $matched_terms[] = "BRAND:" . $supplier_brand;
                } elseif (self::is_same_brand($supplier_brand, $db_brand)) {
                    $score += 35;
                    $matched_terms[] = "BRAND:" . $supplier_brand;
                }
            }
            
            // Model/Series match
            if ($supplier_model && $db_model) {
                if (mb_strtolower($supplier_model) === mb_strtolower($db_model)) {
                    $score += 20;
                    $matched_terms[] = "SERIES:" . $supplier_model;
                } elseif (mb_stripos($db_model, $supplier_model) !== false || 
                          mb_stripos($supplier_model, $db_model) !== false) {
                    $score += 15;
                    $matched_terms[] = "SERIES:" . $supplier_model;
                }
            }
            
            // Vitola match
            if ($supplier_vitola && $db_vitola) {
                if (mb_strtolower($supplier_vitola) === mb_strtolower($db_vitola)) {
                    $score += 15;
                    $matched_terms[] = "VITOLA:" . $supplier_vitola;
                } elseif (mb_stripos($db_vitola, $supplier_vitola) !== false || 
                          mb_stripos($supplier_vitola, $db_vitola) !== false) {
                    $score += 10;
                    $matched_terms[] = "VITOLA:" . $supplier_vitola;
                }
            }
            
            // Special edition match
            if ($supplier_special && $db_special) {
                if (mb_strtolower($supplier_special) === mb_strtolower($db_special)) {
                    $score += 10;
                    $matched_terms[] = "SPECIAL:" . $supplier_special;
                } elseif (mb_stripos($db_special, $supplier_special) !== false || 
                          mb_stripos($supplier_special, $db_special) !== false) {
                    $score += 7;
                    $matched_terms[] = "SPECIAL:" . $supplier_special;
                } elseif ((mb_stripos($supplier_special, 'limited') !== false && 
                           mb_stripos($db_special, 'limited') !== false) ||
                          (mb_stripos($supplier_special, 'regional') !== false && 
                           mb_stripos($db_special, 'regional') !== false)) {
                    $score += 5;
                    $matched_terms[] = "SPECIAL:" . $supplier_special;
                }
            }
            
            // Year match
            if ($supplier_year && $db_year) {
                if ($supplier_year === $db_year) {
                    $score += 10;
                    $matched_terms[] = "YEAR:" . $supplier_year;
                } elseif (abs(intval($supplier_year) - intval($db_year)) <= 1) {
                    $score += 5;
                    $matched_terms[] = "YEAR:" . $supplier_year;
                }
            }
            
            // Ring gauge match
            if ($supplier_ring && $db_ring) {
                if (abs(intval($supplier_ring) - intval($db_ring)) <= 1) {
                    $score += 5;
                    if (!in_array("DIM:" . $supplier_ring . "/" . $supplier_length, $matched_terms)) {
                        $matched_terms[] = "DIM:" . $supplier_ring . "/" . $supplier_length;
                    }
                } elseif (abs(intval($supplier_ring) - intval($db_ring)) <= 3) {
                    $score += 3;
                    if (!in_array("DIM:" . $supplier_ring . "/" . $supplier_length, $matched_terms)) {
                        $matched_terms[] = "DIM:" . $supplier_ring . "/" . $supplier_length;
                    }
                }
            }
            
            // Length match
            if ($supplier_length && $db_length) {
                if (abs(intval($supplier_length) - intval($db_length)) <= 5) {
                    $score += 5;
                    if (!in_array("DIM:" . $supplier_ring . "/" . $supplier_length, $matched_terms) && 
                        !empty($supplier_ring)) {
                        $matched_terms[] = "DIM:" . $supplier_ring . "/" . $supplier_length;
                    }
                } elseif (abs(intval($supplier_length) - intval($db_length)) <= 10) {
                    $score += 3;
                    if (!in_array("DIM:" . $supplier_ring . "/" . $supplier_length, $matched_terms) && 
                        !empty($supplier_ring)) {
                        $matched_terms[] = "DIM:" . $supplier_ring . "/" . $supplier_length;
                    }
                }
            }
            
            // Keyword matches
            foreach ($supplier_keywords as $supplier_keyword) {
                // Skip FULL keyword as it's just the full title
                if (strpos($supplier_keyword, 'FULL:') === 0) {
                    continue;
                }
                
                foreach ($db_keywords as $db_keyword) {
                    // Skip FULL keyword
                    if (strpos($db_keyword, 'FULL:') === 0) {
                        continue;
                    }
                    
                    // Extract tag and value for comparison
                    $supplier_tag = '';
                    $supplier_value = $supplier_keyword;
                    
                    if (strpos($supplier_keyword, ':') !== false) {
                        list($supplier_tag, $supplier_value) = explode(':', $supplier_keyword, 2);
                    }
                    
                    $db_tag = '';
                    $db_value = $db_keyword;
                    
                    if (strpos($db_keyword, ':') !== false) {
                        list($db_tag, $db_value) = explode(':', $db_keyword, 2);
                    }
                    
                    // If both have tags and they don't match, skip
                    if (!empty($supplier_tag) && !empty($db_tag) && $supplier_tag !== $db_tag) {
                        continue;
                    }
                    
                    // Direct value match
                    if (mb_strtolower(trim($supplier_value)) === mb_strtolower(trim($db_value))) {
                        $score += 3;
                        if (!in_array($supplier_keyword, $matched_terms)) {
                            $matched_terms[] = $supplier_keyword;
                        }
                    }
                    // Partial value match for longer strings
                    elseif (mb_strlen($supplier_value) > 3 && mb_strlen($db_value) > 3 &&
                           (mb_stripos($db_value, $supplier_value) !== false || 
                            mb_stripos($supplier_value, $db_value) !== false)) {
                        $score += 1;
                        if (!in_array($supplier_keyword, $matched_terms)) {
                            $matched_terms[] = $supplier_keyword;
                        }
                    }
                }
            }
            
            // Chinese character bonus
            $has_chinese = false;
            foreach ($supplier_keywords as $keyword) {
                if (preg_match('/[\x{4e00}-\x{9fa5}]/u', $keyword)) {
                    $has_chinese = true;
                    break;
                }
            }
            
            if ($has_chinese) {
                // Give bonus for Chinese character matches which are more specific
                foreach ($supplier_keywords as $supplier_keyword) {
                    // Skip tags
                    if (strpos($supplier_keyword, ':') !== false) {
                        continue;
                    }
                    
                    if (preg_match('/[\x{4e00}-\x{9fa5}]{2,}/u', $supplier_keyword)) {
                        foreach ($db_keywords as $db_keyword) {
                            // Skip tags
                            if (strpos($db_keyword, ':') !== false) {
                                continue;
                            }
                            
                            if (mb_stripos($db_keyword, $supplier_keyword) !== false || 
                                mb_stripos($supplier_keyword, $db_keyword) !== false) {
                                $score += 2;
                                if (!in_array($supplier_keyword, $matched_terms)) {
                                    $matched_terms[] = $supplier_keyword;
                                }
                                break;
                            }
                        }
                    }
                }
            }
            
            // Normalize score to 0-100
            $normalized_score = min(100, round($score));
            
            // Determine match type
            $match_type = "No Match";
            if ($normalized_score >= 80) {
                if ($supplier_brand && $db_brand && self::is_same_brand($supplier_brand, $db_brand)) {
                    $match_type = "Exact Match";
                } else {
                    $match_type = "Close Match";
                }
            } elseif ($normalized_score >= 50) {
                $match_type = "Close Match";
            } elseif ($normalized_score >= 30) {
                $match_type = "Possible Match";
            }
            
            // Add to matches array
            $matches[] = array(
                "product" => $db_product,
                "score" => $normalized_score,
                "match_type" => $match_type,
                "matched_terms" => $matched_terms
            );
        }
        
        // Sort matches by score (descending)
        usort($matches, function($a, $b) {
            return $b["score"] <=> $a["score"];
        });
        
        // Limit results
        return array_slice($matches, 0, $max_results);
    }
    
    /**
     * Extract specified keywords from a product title
     * 
     * @param string $title Product title
     * @param array $categories Categories to extract (e.g. ['brand', 'vitola'])
     * @return array Extracted keywords by category
     */
    public static function extract_keywords($title, $categories = array()) {
        // Default to all categories if none specified
        if (empty($categories)) {
            $categories = array('brand', 'model', 'vitola', 'special_edition', 'year', 'count', 'dimensions', 'packaging');
        }
        
        // Process the title
        $processed = self::process_supplier_product($title);
        
        // Extract requested categories
        $result = array();
        
        foreach ($categories as $category) {
            switch ($category) {
                case 'brand':
                    $result['brand'] = $processed['brand'];
                    break;
                case 'model':
                    $result['model'] = $processed['model'];
                    break;
                case 'vitola':
                    $result['vitola'] = $processed['vitola'];
                    break;
                case 'special_edition':
                    $result['special_edition'] = $processed['special_edition'];
                    break;
                case 'year':
                    $result['year'] = $processed['year'];
                    break;
                case 'count':
                    $result['count'] = $processed['count'];
                    break;
                case 'dimensions':
                    $result['dimensions'] = $processed['dimension_info'];
                    break;
                case 'packaging':
                    $result['packaging'] = $processed['packaging'];
                    break;
                case 'keywords':
                    $result['keywords'] = $processed['keywords'];
                    break;
            }
        }
        
        return $result;
    }
    
    /**
     * Format extraction results for display
     * 
     * @param array $extraction_results Results from extract_keywords()
     * @return array Formatted results for display
     */
    public static function format_extraction_for_display($extraction_results) {
        $display = array();
        
        foreach ($extraction_results as $category => $value) {
            if (empty($value)) {
                continue;
            }
            
            switch ($category) {
                case 'brand':
                    $display[] = array(
                        'label' => 'Brand',
                        'value' => $value,
                        'category' => 'brand'
                    );
                    break;
                case 'model':
                    $display[] = array(
                        'label' => 'Series/Model',
                        'value' => $value,
                        'category' => 'model'
                    );
                    break;
                case 'vitola':
                    $display[] = array(
                        'label' => 'Vitola/Size',
                        'value' => $value,
                        'category' => 'vitola'
                    );
                    break;
                case 'special_edition':
                    $display[] = array(
                        'label' => 'Special Edition',
                        'value' => $value,
                        'category' => 'special_edition'
                    );
                    break;
                case 'year':
                    $display[] = array(
                        'label' => 'Year',
                        'value' => $value,
                        'category' => 'year'
                    );
                    break;
                case 'count':
                    $display[] = array(
                        'label' => 'Count',
                        'value' => $value,
                        'category' => 'count'
                    );
                    break;
                case 'dimensions':
                    if (!empty($value['ring_gauge']) || !empty($value['length'])) {
                        $dim_text = '';
                        if (!empty($value['ring_gauge'])) {
                            $dim_text .= 'Ring: ' . $value['ring_gauge'];
                        }
                        if (!empty($value['length'])) {
                            if (!empty($dim_text)) {
                                $dim_text .= ', ';
                            }
                            $dim_text .= 'Length: ' . $value['length'];
                        }
                        
                        $display[] = array(
                            'label' => 'Dimensions',
                            'value' => $dim_text,
                            'category' => 'dimensions'
                        );
                    }
                    break;
                case 'packaging':
                    $display[] = array(
                        'label' => 'Packaging',
                        'value' => $value,
                        'category' => 'packaging'
                    );
                    break;
                case 'keywords':
                    $keywords_by_category = array();
                    
                    foreach ($value as $keyword) {
                        // Skip FULL keyword
                        if (strpos($keyword, 'FULL:') === 0) {
                            continue;
                        }
                        
                        // Determine category
                        $category = self::categorize_keyword($keyword);
                        
                        // Clean up tagged keywords
                        if (strpos($keyword, ':') !== false) {
                            list($tag, $keyword_value) = explode(':', $keyword, 2);
                            $keyword = $keyword_value;
                        }
                        
                        if (!isset($keywords_by_category[$category])) {
                            $keywords_by_category[$category] = array();
                        }
                        
                        $keywords_by_category[$category][] = $keyword;
                    }
                    
                    // Add each category to display
                    foreach ($keywords_by_category as $cat => $keywords) {
                        $label = ucfirst($cat);
                        if ($cat === 'model') $label = 'Series/Model';
                        if ($cat === 'special_edition') $label = 'Special Edition';
                        
                        $display[] = array(
                            'label' => $label . ' Keywords',
                            'value' => implode(', ', $keywords),
                            'category' => $cat,
                            'is_keyword_list' => true
                        );
                    }
                    break;
            }
        }
        
        return $display;
    }
    
    /**
     * Get all brands from the data file
     * 
     * @return array Array of all brands
     */
    public static function get_all_brands() {
        // Make sure we're initialized
        self::init();
        
        $brands = array();
        
        if (isset(self::$data_file['brands'])) {
            foreach (self::$data_file['brands'] as $origin => $origin_brands) {
                foreach ($origin_brands as $brand => $variations) {
                    $brands[] = $brand;
                }
            }
        }
        
        sort($brands);
        return $brands;
    }
    
    /**
     * Get all series for a specific brand
     * 
     * @param string $brand Brand name
     * @return array Array of series for the brand
     */
    public static function get_brand_series($brand) {
        // Make sure we're initialized
        self::init();
        
        $series = array();
        
       if (!empty($brand) && isset(self::$data_file['series'][$brand])) {
            foreach (self::$data_file['series'][$brand] as $series_name => $variations) {
                $series[] = $series_name;
            }
        }
        
        sort($series);
        return $series;
    }
    
    /**
     * Get all vitolas from the data file
     * 
     * @return array Array of all vitolas
     */
    public static function get_all_vitolas() {
        // Make sure we're initialized
        self::init();
        
        $vitolas = array();
        
        if (isset(self::$data_file['vitola_mappings'])) {
            foreach (self::$data_file['vitola_mappings'] as $vitola => $variations) {
                $vitolas[] = $vitola;
            }
        }
        
        if (isset(self::$data_file['sizes'])) {
            foreach (self::$data_file['sizes'] as $size => $variations) {
                if (!in_array($size, $vitolas)) {
                    $vitolas[] = $size;
                }
            }
        }
        
        sort($vitolas);
        return $vitolas;
    }
    
    /**
     * Get all special editions from the data file
     * 
     * @return array Array of all special editions
     */
    public static function get_all_special_editions() {
        // Make sure we're initialized
        self::init();
        
        $special_editions = array();
        
        if (isset(self::$data_file['special_editions'])) {
            foreach (self::$data_file['special_editions'] as $edition => $variations) {
                $special_editions[] = $edition;
            }
        }
        
        // Add limited editions by year
        if (isset(self::$data_file['limited_editions_by_year'])) {
            foreach (self::$data_file['limited_editions_by_year'] as $year => $editions) {
                $special_editions[] = $year . " Limited Edition";
            }
        }
        
        // Add "Year of the X" editions
        if (isset(self::$data_file['zodiac_years'])) {
            foreach (self::$data_file['zodiac_years'] as $zodiac => $variations) {
                $special_editions[] = "Year of the " . ucfirst($zodiac);
            }
        }
        
        // Add regional editions
        if (isset(self::$data_file['regional_editions'])) {
            foreach (self::$data_file['regional_editions'] as $region => $variations) {
                $special_editions[] = $region . " Regional Edition";
            }
        }
        
        sort($special_editions);
        return $special_editions;
    }
    
    /**
     * Get all packaging types from the data file
     * 
     * @return array Array of all packaging types
     */
    public static function get_all_packaging_types() {
        // Make sure we're initialized
        self::init();
        
        $packaging_types = array();
        
        if (isset(self::$data_file['packaging'])) {
            foreach (self::$data_file['packaging'] as $type => $variations) {
                $packaging_types[] = $type;
            }
        }
        
        sort($packaging_types);
        return $packaging_types;
    }
    
    /**
     * Get all brand variations for a specific brand
     * 
     * @param string $brand Brand name
     * @return array Array of variations for the brand
     */
    public static function get_brand_variations($brand) {
        // Make sure we're initialized
        self::init();
        
        $variations = array();
        
        if (empty($brand)) {
            return $variations;
        }
        
        // Search for the brand in both Cuban and non-Cuban sections
        if (isset(self::$data_file['brands'])) {
            foreach (self::$data_file['brands'] as $origin => $brands) {
                if (isset($brands[$brand])) {
                    $variations = $brands[$brand];
                    break;
                }
            }
        }
        
        // Add aliases as variations
        if (isset(self::$data_file['brand_aliases'])) {
            foreach (self::$data_file['brand_aliases'] as $alias => $alias_brand) {
                if ($alias_brand === $brand) {
                    $variations[] = $alias;
                }
            }
        }
        
        sort($variations);
        return $variations;
    }
    
    /**
     * Get all series variations for a specific brand and series
     * 
     * @param string $brand Brand name
     * @param string $series Series name
     * @return array Array of variations for the series
     */
    public static function get_series_variations($brand, $series) {
        // Make sure we're initialized
        self::init();
        
        $variations = array();
        
        if (empty($brand) || empty($series)) {
            return $variations;
        }
        
        if (isset(self::$data_file['series'][$brand][$series])) {
            $variations = self::$data_file['series'][$brand][$series];
        }
        
        sort($variations);
        return $variations;
    }
    
    /**
     * Get all vitola variations for a specific vitola
     * 
     * @param string $vitola Vitola name
     * @return array Array of variations for the vitola
     */
    public static function get_vitola_variations($vitola) {
        // Make sure we're initialized
        self::init();
        
        $variations = array();
        
        if (empty($vitola)) {
            return $variations;
        }
        
        if (isset(self::$data_file['vitola_mappings'][$vitola])) {
            $variations = self::$data_file['vitola_mappings'][$vitola];
        } elseif (isset(self::$data_file['sizes'][$vitola])) {
            $variations = self::$data_file['sizes'][$vitola];
        }
        
        sort($variations);
        return $variations;
    }
    
    /**
     * Get all special edition variations for a specific special edition
     * 
     * @param string $special_edition Special edition name
     * @return array Array of variations for the special edition
     */
    public static function get_special_edition_variations($special_edition) {
        // Make sure we're initialized
        self::init();
        
        $variations = array();
        
        if (empty($special_edition)) {
            return $variations;
        }
        
        if (isset(self::$data_file['special_editions'][$special_edition])) {
            $variations = self::$data_file['special_editions'][$special_edition];
        }
        
        // Check for year pattern
        if (preg_match('/^(\d{4}) Limited Edition$/', $special_edition, $matches)) {
            $year = $matches[1];
            if (isset(self::$data_file['limited_editions_by_year'][$year])) {
                $variations = array_merge($variations, array(
                    $year . " Edicion Limitada",
                    $year . " LE",
                    "Edicion Limitada " . $year,
                    "Limited Edition " . $year,
                    "LE " . $year
                ));
            }
        }
        
        // Check for "Year of the X" pattern
        if (preg_match('/^Year of the (.+)$/', $special_edition, $matches)) {
            $zodiac = strtolower($matches[1]);
            if (isset(self::$data_file['zodiac_years'][$zodiac])) {
                $variations = array_merge($variations, self::$data_file['zodiac_years'][$zodiac]);
            }
        }
        
        // Check for regional edition pattern
        if (preg_match('/^(.+) Regional Edition$/', $special_edition, $matches)) {
            $region = $matches[1];
            if (isset(self::$data_file['regional_editions'][$region])) {
                $variations = array_merge($variations, self::$data_file['regional_editions'][$region]);
                $variations[] = $region . " Exclusivo";
                $variations[] = $region . " Exclusive";
                $variations[] = "Exclusivo " . $region;
                $variations[] = "Exclusive " . $region;
                $variations[] = "RE " . $region;
                $variations[] = "ER " . $region;
            }
        }
        
        sort($variations);
        return $variations;
    }
    
    /**
     * Get all packaging variations for a specific packaging type
     * 
     * @param string $packaging Packaging type
     * @return array Array of variations for the packaging type
     */
    public static function get_packaging_variations($packaging) {
        // Make sure we're initialized
        self::init();
        
        $variations = array();
        
        if (empty($packaging)) {
            return $variations;
        }
        
        if (isset(self::$data_file['packaging'][$packaging])) {
            $variations = self::$data_file['packaging'][$packaging];
        }
        
        sort($variations);
        return $variations;
    }
    
    /**
     * Check if a brand is Cuban
     * 
     * @param string $brand Brand name
     * @return bool True if the brand is Cuban
     */
    public static function is_cuban_brand($brand) {
        // Make sure we're initialized
        self::init();
        
        if (empty($brand)) {
            return false;
        }
        
        if (isset(self::$data_file['brands']['cuban'][$brand])) {
            return true;
        }
        
        // Check aliases
        if (isset(self::$data_file['brand_aliases'])) {
            foreach (self::$data_file['brand_aliases'] as $alias => $alias_brand) {
                if (strtolower($alias) === strtolower($brand) && 
                    isset(self::$data_file['brands']['cuban'][$alias_brand])) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if a brand is non-Cuban
     * 
     * @param string $brand Brand name
     * @return bool True if the brand is non-Cuban
     */
    public static function is_non_cuban_brand($brand) {
        // Make sure we're initialized
        self::init();
        
        if (empty($brand)) {
            return false;
        }
        
        if (isset(self::$data_file['brands']['non_cuban'][$brand])) {
            return true;
        }
        
        // Check aliases
        if (isset(self::$data_file['brand_aliases'])) {
            foreach (self::$data_file['brand_aliases'] as $alias => $alias_brand) {
                if (strtolower($alias) === strtolower($brand) && 
                    isset(self::$data_file['brands']['non_cuban'][$alias_brand])) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Get brand origin (Cuban or non-Cuban)
     * 
     * @param string $brand Brand name
     * @return string|null 'cuban', 'non_cuban', or null if not found
     */
    public static function get_brand_origin($brand) {
        // Make sure we're initialized
        self::init();
        
        if (empty($brand)) {
            return null;
        }
        
        // Check direct match in Cuban brands
        if (isset(self::$data_file['brands']['cuban'][$brand])) {
            return 'cuban';
        }
        
        // Check direct match in non-Cuban brands
        if (isset(self::$data_file['brands']['non_cuban'][$brand])) {
            return 'non_cuban';
        }
        
        // Check aliases
        if (isset(self::$data_file['brand_aliases'])) {
            foreach (self::$data_file['brand_aliases'] as $alias => $alias_brand) {
                if (strtolower($alias) === strtolower($brand)) {
                    // Check where the aliased brand is from
                    if (isset(self::$data_file['brands']['cuban'][$alias_brand])) {
                        return 'cuban';
                    } elseif (isset(self::$data_file['brands']['non_cuban'][$alias_brand])) {
                        return 'non_cuban';
                    }
                }
            }
        }
        
        // Search variations
        foreach (self::$data_file['brands']['cuban'] as $cuban_brand => $variations) {
            foreach ($variations as $variation) {
                if (strtolower($variation) === strtolower($brand)) {
                    return 'cuban';
                }
            }
        }
        
        foreach (self::$data_file['brands']['non_cuban'] as $non_cuban_brand => $variations) {
            foreach ($variations as $variation) {
                if (strtolower($variation) === strtolower($brand)) {
                    return 'non_cuban';
                }
            }
        }
        
        return null;
    }
    
    /**
     * Get main brand for a variation or alias
     * 
     * @param string $brand_variation Brand variation or alias
     * @return string|null Main brand name or null if not found
     */
    public static function get_main_brand($brand_variation) {
        // Make sure we're initialized
        self::init();
        
        if (empty($brand_variation)) {
            return null;
        }
        
        $brand_variation_lower = strtolower(trim($brand_variation));
        
        // Check if this is already a main brand
        foreach (self::$data_file['brands'] as $origin => $brands) {
            if (isset($brands[$brand_variation])) {
                return $brand_variation;
            }
        }
        
        // Check aliases
        if (isset(self::$data_file['brand_aliases'])) {
            foreach (self::$data_file['brand_aliases'] as $alias => $alias_brand) {
                if (strtolower($alias) === $brand_variation_lower) {
                    return $alias_brand;
                }
            }
        }
        
        // Check variations
        foreach (self::$data_file['brands'] as $origin => $brands) {
            foreach ($brands as $brand => $variations) {
                foreach ($variations as $variation) {
                    if (strtolower($variation) === $brand_variation_lower) {
                        return $brand;
                    }
                }
            }
        }
        
        return null;
    }
    
    /**
     * Check if a year is a limited edition year
     * 
     * @param string|int $year Year to check
     * @return bool True if the year is a limited edition year
     */
    public static function is_limited_edition_year($year) {
        // Make sure we're initialized
        self::init();
        
        if (empty($year)) {
            return false;
        }
        
        $year = (string)$year;
        
        if (isset(self::$data_file['limited_editions_by_year'][$year])) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Get limited editions for a specific year
     * 
     * @param string|int $year Year to check
     * @return array Array of limited editions for the year
     */
    public static function get_limited_editions_by_year($year) {
        // Make sure we're initialized
        self::init();
        
        $editions = array();
        
        if (empty($year)) {
            return $editions;
        }
        
        $year = (string)$year;
        
        if (isset(self::$data_file['limited_editions_by_year'][$year])) {
            $editions = self::$data_file['limited_editions_by_year'][$year];
        }
        
        return $editions;
    }
    
    /**
     * Convert Chinese cigar terms to English
     * 
     * @param string $chinese_text Chinese text to convert
     * @return string English translation if found, or original text
     */
    public static function chinese_to_english($chinese_text) {
        // Make sure we're initialized
        self::init();
        
        // Try brand translations first
        foreach (self::$data_file['brands'] as $origin => $brands) {
            foreach ($brands as $brand => $variations) {
                foreach ($variations as $variation) {
                    if (preg_match('/[\x{4e00}-\x{9fa5}]/u', $variation) && 
                        mb_stripos($chinese_text, $variation) !== false) {
                        return str_replace($variation, $brand, $chinese_text);
                    }
                }
            }
        }
        
        // Try vitola translations
        if (isset(self::$data_file['vitola_mappings'])) {
            foreach (self::$data_file['vitola_mappings'] as $vitola => $variations) {
                foreach ($variations as $variation) {
                    if (preg_match('/[\x{4e00}-\x{9fa5}]/u', $variation) && 
                        mb_stripos($chinese_text, $variation) !== false) {
                        return str_replace($variation, $vitola, $chinese_text);
                    }
                }
            }
        }
        
        // Try model translations
        foreach (self::$data_file['series'] as $brand => $series_list) {
            foreach ($series_list as $series => $variations) {
                foreach ($variations as $variation) {
                    if (preg_match('/[\x{4e00}-\x{9fa5}]/u', $variation) && 
                        mb_stripos($chinese_text, $variation) !== false) {
                        return str_replace($variation, $series, $chinese_text);
                    }
                }
            }
        }
        
        // Try zodiac years
        if (isset(self::$data_file['zodiac_years'])) {
            foreach (self::$data_file['zodiac_years'] as $zodiac => $variations) {
                foreach ($variations as $variation) {
                    if (preg_match('/[\x{4e00}-\x{9fa5}]/u', $variation) && 
                        mb_stripos($chinese_text, $variation) !== false) {
                        return str_replace($variation, "Year of the " . ucfirst($zodiac), $chinese_text);
                    }
                }
            }
        }
        
        // Try packaging translations
        if (isset(self::$data_file['packaging'])) {
            foreach (self::$data_file['packaging'] as $packaging => $variations) {
                foreach ($variations as $variation) {
                    if (preg_match('/[\x{4e00}-\x{9fa5}]/u', $variation) && 
                        mb_stripos($chinese_text, $variation) !== false) {
                        return str_replace($variation, $packaging, $chinese_text);
                    }
                }
            }
        }
        
        // If we reached here, we couldn't find a translation
        return $chinese_text;
    }
    
    /**
     * Get the data file contents
     * 
     * @return array The data file contents
     */
    public static function get_data_file() {
        // Make sure we're initialized
        self::init();
        
        return self::$data_file;
    }
}

// Initialize the class if not already done
KT_Cigar_Mappings::init();
